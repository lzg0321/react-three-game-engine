{"version":3,"file":"react-three-game-engine.cjs.production.min.js","sources":["../src/main/worker/shared/types.ts","../src/main/worker/planckjs/bodies.ts","../src/shared/types.ts","../src/shared/PhysicsProvider.tsx","../src/shared/StoredPhysicsData.tsx","../src/utils/numbers.ts","../src/shared/MeshSubscriptions.tsx","../src/shared/utils.ts","../src/main/hooks/useBody.ts","../src/shared/WorkerOnMessageProvider.tsx","../src/shared/PhysicsSync.tsx","../src/main/worker/planckjs/config.ts","../src/main/hooks/useWorkerMessages.ts","../src/main/PhysicsWorker.tsx","../src/main/R3FPhysicsObjectUpdater.tsx","../src/shared/CollisionsProvider.tsx","../src/main/MeshRefs.tsx","../src/shared/Messages.tsx","../src/main/LogicHandler.tsx","../src/shared/SendMessages.tsx","../src/main/LogicWorker.tsx","../src/logic/logicWorkerApp/PhysicsHandler.tsx","../src/logic/logicWorkerApp/MessageHandler.tsx","../src/logic/ApiWrapper.tsx","../src/logic/logicWorkerApp/hooks/messaging.ts","../src/main/Body.tsx","../src/main/Engine.tsx","../src/logic/workerHelper.ts","../src/main/worker/physicsWorkerHelper.ts","../src/main/hooks/useCollisionEvents.ts","../src/logic/logicWorkerApp/hooks/sync.ts"],"sourcesContent":["import { WorldDef } from 'planck-js';\n\nexport enum WorkerMessageType {\n  INIT,\n  STEP,\n  LOGIC_FRAME,\n  ADD_BODY,\n  REMOVE_BODY,\n  SET_BODY,\n  UPDATE_BODY,\n  PHYSICS_STEP_PROCESSED,\n  READY_FOR_PHYSICS,\n}\n\nexport enum WorkerOwnerMessageType {\n  FRAME,\n  PHYSICS_STEP,\n  SYNC_BODIES,\n  BEGIN_COLLISION,\n  END_COLLISION,\n  MESSAGE,\n  INITIATED,\n}\n\nexport type Buffers = {\n  positions: Float32Array;\n  angles: Float32Array;\n};\n\nexport type ValidUUID = string | number;\n\nexport type PhysicsProps = {\n  config?: {\n    maxNumberOfDynamicObjects?: number;\n    updateRate?: number;\n  };\n  worldParams?: WorldDef;\n};\n","import {dynamicBodiesUuids, existingBodies, planckWorld} from \"./shared\";\nimport {Shape} from \"planck-js/lib/shape\";\nimport {activeCollisionListeners} from \"./collisions/data\";\nimport {addCachedBody, getCachedBody} from \"./cache\";\nimport type {BodyDef, FixtureOpt, Body, Joint} from \"planck-js\";\nimport {Box, Circle, DistanceJoint, RopeJoint, Vec2} from \"planck-js\";\nimport {ValidUUID} from \"../shared/types\";\nimport {syncBodies} from \"../shared\";\n\nexport enum BodyType {\n    static = 'static',\n    kinematic = 'kinematic',\n    dynamic = 'dynamic'\n}\n\nexport enum BodyShape {\n    box = 'box',\n    circle = 'circle',\n}\n\nexport type FixtureBase = {\n    shape: BodyShape,\n    fixtureOptions?: Partial<FixtureOpt>,\n}\n\nexport type BoxFixture = FixtureBase & {\n    hx: number,\n    hy: number,\n    center?: [number, number],\n    angle?: number,\n}\n\nexport const createBoxFixture = ({\n                                     width = 1,\n                                     height = 1,\n                                     center,\n                                        angle,\n                                     fixtureOptions = {}\n                                 }: {\n    width?: number,\n    height?: number,\n    angle?: number,\n    center?: [number, number],\n    fixtureOptions?: Partial<FixtureOpt>\n}): BoxFixture => {\n    const fixture: BoxFixture = {\n        shape: BodyShape.box,\n        hx: width,\n        hy: height,\n        fixtureOptions,\n    }\n    if (angle) {\n        fixture.angle = angle\n    }\n    if (center) {\n        fixture.center = center\n    }\n    return fixture\n}\n\nexport type CircleFixture = FixtureBase & {\n    radius: number,\n    position?: [number, number],\n}\n\nexport const createCircleFixture = ({ radius = 1, position, fixtureOptions = {} }: {\n    radius?: number,\n    position?: [number, number],\n    fixtureOptions?: Partial<FixtureOpt>\n}): CircleFixture => {\n    return {\n        shape: BodyShape.circle,\n        radius,\n        position,\n        fixtureOptions,\n    }\n}\n\ntype Fixture = BoxFixture | CircleFixture\n\ntype BasicBodyProps = Partial<BodyDef> & {\n    fixtures?: Fixture[],\n}\n\ntype AddBoxBodyProps = BasicBodyProps & {}\n\ntype AddCircleBodyProps = BasicBodyProps & {}\n\nexport type AddBodyDef = BasicBodyProps | AddBoxBodyProps | AddCircleBodyProps\n\nexport type AddBodyProps = AddBodyDef & {\n    uuid: ValidUUID,\n    listenForCollisions: boolean,\n    cacheKey?: string,\n    attachToRope?: boolean,\n}\n\nexport const addBody = ({uuid, cacheKey, listenForCollisions, fixtures = [], attachToRope = false, ...props}: AddBodyProps) => {\n\n    const existingBody = existingBodies.get(uuid)\n\n    if (existingBody) {\n        return existingBody\n    }\n\n    if (listenForCollisions) {\n        activeCollisionListeners[uuid] = true\n    }\n\n    const bodyDef: BodyDef = {\n        type: BodyType.static,\n        fixedRotation: true,\n        ...props,\n    }\n\n    const {type} = bodyDef\n\n    let body: Body | null = null;\n\n    if (cacheKey) {\n        const cachedBody = getCachedBody(cacheKey)\n        if (cachedBody) {\n\n            if (fixtures && fixtures.length > 0) {\n\n                let bodyFixture = cachedBody.getFixtureList()\n\n                fixtures.forEach((fixture, fixtureIndex) => {\n\n                    let fixtureOptions = fixture.fixtureOptions\n\n                    fixtureOptions = {\n                        userData: {\n                            uuid,\n                            fixtureIndex,\n                            ...fixtureOptions?.userData\n                        },\n                        ...fixtureOptions,\n                    }\n\n                    if (bodyFixture) {\n\n                        if (fixtureOptions) {\n                            bodyFixture.setUserData(fixtureOptions.userData)\n                        }\n\n                        bodyFixture = bodyFixture.getNext()\n                    }\n\n                })\n\n            }\n\n            const {position, angle} = props\n\n            if (position) {\n                cachedBody.setPosition(position)\n            }\n\n            if (angle) {\n                cachedBody.setAngle(angle)\n            }\n\n            cachedBody.setActive(true)\n\n            body = cachedBody\n\n        }\n    }\n\n    if (!body) {\n\n        body = planckWorld.createBody(bodyDef)\n\n        if (fixtures && fixtures.length > 0) {\n\n            fixtures.forEach((fixture, fixtureIndex) => {\n\n                const {shape} = fixture\n\n                let fixtureOptions = fixture.fixtureOptions ?? {}\n\n                fixtureOptions = {\n                    ...fixtureOptions,\n                    userData: {\n                        uuid,\n                        fixtureIndex,\n                        ...fixtureOptions?.userData\n                    },\n                }\n\n                let bodyShape: Shape;\n\n                switch (shape) {\n                    case BodyShape.box:\n                        const {hx, hy, center} = fixture as BoxFixture\n                        bodyShape = Box((hx as number) / 2, (hy as number) / 2, center ? Vec2(center[0], center[1]) : undefined) as unknown as Shape\n                        break;\n                    case BodyShape.circle:\n                        const {radius} = fixture as CircleFixture\n                        bodyShape = Circle((radius as number)) as unknown as Shape\n                        break;\n                    default:\n                        throw new Error(`Unhandled body shape ${shape}`)\n                }\n\n                if (fixtureOptions) {\n                    if (body) {\n                        body.createFixture(bodyShape, fixtureOptions as FixtureOpt)\n                    }\n                } else {\n                    if (body) {\n                        body.createFixture(bodyShape)\n                    }\n                }\n\n                // todo - handle rope properly...\n                if (attachToRope) {\n\n                    const {position, angle} = props\n\n                    const ropeJointDef = {\n                        maxLength: 0.5,\n                        localAnchorA: position,\n                        localAnchorB: position,\n                    };\n\n                    const startingBodyDef: BodyDef = {\n                        type: BodyType.static,\n                        fixedRotation: true,\n                        position,\n                        angle,\n                    }\n\n                    const startingBody = planckWorld.createBody(startingBodyDef)\n\n                    if (body) {\n\n                        const distanceJoint = DistanceJoint({\n                            collideConnected: false,\n                            frequencyHz: 5,\n                            dampingRatio: 0.5,\n                            length: 0.15,\n                        }, startingBody, body, position ?? Vec2(0, 0), position ?? Vec2(0, 0))\n\n                        const rope2 = planckWorld.createJoint(RopeJoint(ropeJointDef, startingBody, body, position ?? Vec2(0, 0)) as unknown as Joint);\n                        const rope = planckWorld.createJoint(distanceJoint as unknown as Joint);\n                    }\n\n\n                }\n\n            })\n\n\n        }\n\n    }\n\n    if (type !== BodyType.static) {\n        dynamicBodiesUuids.push(uuid)\n        syncBodies()\n    }\n\n    if (!body) {\n        throw new Error(`No body`)\n    }\n\n    existingBodies.set(uuid, body)\n\n    return body\n\n}\n\nexport type RemoveBodyProps = {\n    uuid: ValidUUID,\n    cacheKey?: string\n}\n\nconst tempVec = Vec2(0, 0)\n\nexport const removeBody = ({uuid, cacheKey}: RemoveBodyProps) => {\n    const index = dynamicBodiesUuids.indexOf(uuid)\n    if (index > -1) {\n        dynamicBodiesUuids.splice(index, 1)\n        syncBodies()\n    }\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    existingBodies.delete(uuid)\n    if (cacheKey) {\n        tempVec.set(-1000, -1000)\n        body.setPosition(tempVec)\n        tempVec.set(0, 0)\n        body.setLinearVelocity(tempVec)\n        body.setActive(false)\n        addCachedBody(cacheKey, body)\n    } else {\n        planckWorld.destroyBody(body)\n    }\n}\n\nexport type SetBodyProps = {\n    uuid: ValidUUID,\n    method: string,\n    methodParams: any[],\n}\n\nexport const setBody = ({uuid, method, methodParams}: SetBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    switch (method) {\n        //case 'setAngle':\n        //    const [angle] = methodParams\n        //    body.setTransform(body.getPosition(), angle)\n        //    break;\n        case 'setLinearVelocity':\n            // console.log('methodParams', methodParams[0].x, methodParams[0].y);\n            (body as any)[method](...methodParams)\n            break;\n        default:\n            (body as any)[method](...methodParams)\n    }\n}\n\nexport type UpdateBodyData = {\n    fixtureUpdate?: {\n        groupIndex?: number,\n        categoryBits?: number,\n        maskBits?: number,\n    }\n}\n\nexport type UpdateBodyProps = {\n    uuid: ValidUUID,\n    data: UpdateBodyData,\n}\n\nexport const updateBody = ({uuid, data}: UpdateBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    const {fixtureUpdate} = data\n    if (fixtureUpdate) {\n        const fixture = body.getFixtureList()\n        if (fixture) {\n            const {\n                groupIndex,\n                categoryBits,\n                maskBits\n            } = fixtureUpdate\n            if (\n                groupIndex !== undefined || categoryBits !== undefined || maskBits !== undefined\n            ) {\n                const originalGroupIndex = fixture.getFilterGroupIndex()\n                const originalCategoryBits = fixture.getFilterCategoryBits()\n                const originalMaskBits = fixture.getFilterMaskBits()\n                fixture.setFilterData({\n                    groupIndex: groupIndex !== undefined ? groupIndex : originalGroupIndex,\n                    categoryBits: categoryBits !== undefined ? categoryBits : originalCategoryBits,\n                    maskBits: maskBits !== undefined ? maskBits : originalMaskBits,\n                })\n            }\n        }\n    }\n}\n","export enum MessageKeys {\n  SYNC_COMPONENT = 'SYNC_COMPONENT',\n}\n\nexport type MessageData = {\n  key: string;\n  data: any;\n};\n\nexport enum SyncComponentMessageType {\n  MOUNT,\n  UNMOUNT,\n  UPDATE,\n}\n\nexport enum SyncComponentType {\n  PLAYER,\n}\n\nexport type SyncComponentMessageInfo = {\n  componentType: SyncComponentType;\n  componentKey: string;\n};\n\nexport type ValidProps =\n  | undefined\n  | {\n      [key: string]: any;\n    };\n\nexport type SyncComponentMessage = {\n  data: ValidProps;\n  info: SyncComponentMessageInfo;\n  messageType: SyncComponentMessageType;\n};\n\nexport type MappedComponents = {\n  [key: string]: any;\n};\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport {\n  AddBodyProps,\n  RemoveBodyProps,\n  SetBodyProps,\n  UpdateBodyProps,\n} from '../main/worker/planckjs/bodies';\nimport { WorkerMessageType } from '../main/worker/shared/types';\n\nexport type ContextState = {\n  workerAddBody: (props: AddBodyProps) => void;\n  workerRemoveBody: (props: RemoveBodyProps) => void;\n  workerSetBody: (props: SetBodyProps) => void;\n  workerUpdateBody: (props: UpdateBodyProps) => void;\n};\n\nexport const Context = createContext((null as unknown) as ContextState);\n\nexport const usePhysicsProvider = (): ContextState => {\n  return useContext(Context);\n};\n\nconst PhysicsProvider: React.FC<{\n  worker: Worker | MessagePort;\n}> = ({ children, worker }) => {\n  const workerAddBody = useCallback((props: AddBodyProps) => {\n    worker.postMessage({\n      type: WorkerMessageType.ADD_BODY,\n      props: props,\n    });\n  }, []);\n\n  const workerRemoveBody = useCallback((props: RemoveBodyProps) => {\n    worker.postMessage({\n      type: WorkerMessageType.REMOVE_BODY,\n      props,\n    });\n  }, []);\n\n  const workerSetBody = useCallback((props: SetBodyProps) => {\n    worker.postMessage({\n      type: WorkerMessageType.SET_BODY,\n      props,\n    });\n  }, []);\n\n  const workerUpdateBody = useCallback((props: UpdateBodyProps) => {\n    worker.postMessage({\n      type: WorkerMessageType.UPDATE_BODY,\n      props,\n    });\n  }, []);\n\n  return (\n    <Context.Provider\n      value={{\n        workerAddBody,\n        workerRemoveBody,\n        workerSetBody,\n        workerUpdateBody,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default PhysicsProvider;\n","import React, { createContext, FC, useContext, useState } from 'react';\n\ntype Bodies = {\n  [uuid: string]: number;\n};\n\ntype ContextState = {\n  data: {\n    bodies: Bodies;\n  };\n};\n\nconst Context = createContext((null as unknown) as ContextState);\n\nexport const useStoredData = () => {\n  return useContext(Context).data;\n};\n\nconst StoredPhysicsData: FC = ({ children }) => {\n  const [data] = useState<{\n    bodies: Bodies;\n  }>({\n    bodies: {},\n  });\n\n  return (\n    <Context.Provider\n      value={{\n        data,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default StoredPhysicsData;\n","import { MathUtils } from 'three';\n\nexport const lerp = MathUtils.lerp;\n","import React, {\n    createContext, MutableRefObject,\n    useCallback,\n    useContext,\n    useEffect,\n    useRef,\n    useState,\n} from 'react';\nimport {Object3D} from 'three';\nimport {ValidUUID} from '../main/worker/shared/types';\nimport {getPositionAndAngle} from './utils';\nimport {useStoredData} from './StoredPhysicsData';\nimport {lerp} from '../utils/numbers';\n\nexport type ContextState = {\n    lerpMeshes: (\n        getPhysicsStepTimeRemainingRatio: (time: number) => number\n    ) => void;\n    updateMeshes: (\n        positions: Float32Array,\n        angles: Float32Array,\n        immediate: boolean\n    ) => void;\n    addSubscription: (\n        uuid: ValidUUID,\n        objectRef: MutableRefObject<Object3D>,\n        applyAngle: boolean\n    ) => () => void;\n};\n\nexport const Context = createContext((null as unknown) as ContextState);\n\nexport const useLerpMeshes = () => {\n    return useContext(Context).lerpMeshes;\n};\n\nexport const useAddMeshSubscription = () => {\n    return useContext(Context).addSubscription;\n};\n\nexport const useSubscribeMesh = (\n    uuid: ValidUUID,\n    objectRef: MutableRefObject<Object3D>,\n    applyAngle: boolean = true,\n    isDynamic: boolean = true\n) => {\n    const addSubscription = useContext(Context).addSubscription;\n\n    useEffect(() => {\n        if (!isDynamic) return;\n\n        const unsubscribe = addSubscription(uuid, objectRef, applyAngle);\n\n        return () => {\n            unsubscribe();\n        };\n    }, [uuid, objectRef, applyAngle, isDynamic, addSubscription]);\n};\n\nexport const useUpdateMeshes = () => {\n    return useContext(Context).updateMeshes;\n};\n\nconst MeshSubscriptions: React.FC = ({children}) => {\n    const subscriptionsRef = useRef<{\n        [uuid: string]: {\n            uuid: ValidUUID;\n            objectRef: MutableRefObject<Object3D>;\n            applyAngle: boolean;\n            lastUpdate?: number;\n            target?: {\n                position: [number, number];\n                angle: number;\n            };\n        };\n    }>({});\n\n    const lerpMeshes = useCallback(\n        (getPhysicsStepTimeRemainingRatio: (time: number) => number) => {\n            Object.values(subscriptionsRef.current).forEach(\n                ({uuid, objectRef, target, applyAngle, lastUpdate}) => {\n                    if (!target) return;\n                    const object = objectRef.current\n                    if (!object) return;\n                    const {position, angle} = target;\n                    let physicsRemainingRatio = getPhysicsStepTimeRemainingRatio(\n                        lastUpdate ?? Date.now()\n                    );\n                    object.position.x = lerp(\n                        object.position.x,\n                        position[0],\n                        physicsRemainingRatio\n                    );\n                    object.position.y = lerp(\n                        object.position.y,\n                        position[1],\n                        physicsRemainingRatio\n                    );\n                    if (applyAngle) {\n                        object.rotation.z = angle; // todo - lerp\n                    }\n                    subscriptionsRef.current[uuid as string].lastUpdate = Date.now();\n                }\n            );\n        },\n        [subscriptionsRef]\n    );\n\n    const storedData = useStoredData();\n\n    const updateMeshes = useCallback(\n        (positions: Float32Array, angles: Float32Array, immediate: boolean) => {\n            Object.entries(subscriptionsRef.current).forEach(\n                ([uuid, {objectRef, target, applyAngle}]) => {\n                    const object = objectRef.current\n                    if (!object) return\n                    const index = storedData.bodies[uuid];\n                    const update = getPositionAndAngle({positions, angles}, index);\n                    if (update) {\n                        if (immediate) {\n                            object.position.x = update.position[0];\n                            object.position.y = update.position[1];\n                            if (applyAngle) {\n                                object.rotation.x = update.angle;\n                            }\n                        } else if (target) {\n                            object.position.x = target.position[0];\n                            object.position.y = target.position[1];\n                            if (applyAngle) {\n                                object.rotation.x = target.angle;\n                            }\n                        }\n                        subscriptionsRef.current[uuid].target = {\n                            position: update.position,\n                            angle: update.angle,\n                        };\n                    }\n                }\n            );\n        },\n        [subscriptionsRef, storedData]\n    );\n\n    const addSubscription = useCallback(\n        (uuid: ValidUUID, objectRef: MutableRefObject<Object3D>, applyAngle: boolean) => {\n            subscriptionsRef.current[uuid as string] = {\n                uuid,\n                objectRef,\n                applyAngle,\n            };\n\n            const unsubscribe = () => {\n                delete subscriptionsRef.current[uuid as string];\n            };\n\n            return unsubscribe;\n        },\n        [subscriptionsRef]\n    );\n\n    return (\n        <Context.Provider\n            value={{\n                lerpMeshes,\n                updateMeshes,\n                addSubscription,\n            }}\n        >\n            {children}\n        </Context.Provider>\n    );\n};\n\nexport default MeshSubscriptions;\n","import { Buffers } from '../main/worker/shared/types';\nimport { Object3D } from 'three';\n\nexport const getPositionAndAngle = (\n  buffers: Buffers,\n  index: number\n): {\n  position: [number, number];\n  angle: number;\n} | null => {\n  if (index !== undefined && buffers.positions.length) {\n    const start = index * 2;\n    const position = (buffers.positions.slice(start, start + 2) as unknown) as [\n      number,\n      number\n    ];\n    return {\n      position,\n      angle: buffers.angles[index],\n    };\n  } else {\n    return null;\n  }\n};\nexport const applyPositionAngle = (\n  buffers: Buffers,\n  object: Object3D | null,\n  index: number,\n  applyAngle: boolean = false\n) => {\n  if (index !== undefined && buffers.positions.length && !!object) {\n    const start = index * 2;\n    const position = buffers.positions.slice(start, start + 2);\n    object.position.x = position[0];\n    object.position.y = position[1];\n    if (applyAngle) {\n      object.rotation.z = buffers.angles[index];\n    }\n  } else {\n    // console.warn('no match?')\n  }\n};\n","import {\n  AddBodyDef,\n  BodyType,\n  UpdateBodyData,\n} from '../worker/planckjs/bodies';\nimport {\n  MutableRefObject,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Object3D } from 'three';\nimport { usePhysicsProvider } from '../../shared/PhysicsProvider';\nimport { ValidUUID } from '../worker/shared/types';\nimport { Vec2 } from 'planck-js';\nimport {\n  useAddMeshSubscription,\n  useSubscribeMesh,\n} from '../../shared/MeshSubscriptions';\n\nexport type BodyApi = {\n  applyForceToCenter: (vec: Vec2, uuid?: ValidUUID) => void;\n  applyLinearImpulse: (vec: Vec2, pos: Vec2, uuid?: ValidUUID) => void;\n  setAwake: (flag: boolean, uuid?: ValidUUID) => void;\n  setPosition: (vec: Vec2, uuid?: ValidUUID) => void;\n  setLinearVelocity: (vec: Vec2, uuid?: ValidUUID) => void;\n  setAngle: (angle: number, uuid?: ValidUUID) => void;\n  updateBody: (data: UpdateBodyData, uuid?: ValidUUID) => void;\n};\n\nexport const useBodyApi = (passedUuid: ValidUUID): BodyApi => {\n  const { workerSetBody, workerUpdateBody } = usePhysicsProvider();\n\n  const api = useMemo<BodyApi>(() => {\n    return {\n      applyForceToCenter: (vec, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'applyForceToCenter',\n          methodParams: [vec, true],\n        });\n      },\n      applyLinearImpulse: (vec, pos, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'applyLinearImpulse',\n          methodParams: [vec, pos, true],\n        });\n      },\n      setPosition: (vec, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'setPosition',\n          methodParams: [vec],\n        });\n      },\n      setAwake: (flag, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'setAwake',\n          methodParams: [flag],\n        });\n      },\n      setLinearVelocity: (vec, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'setLinearVelocity',\n          methodParams: [vec],\n        });\n      },\n      updateBody: (data: UpdateBodyData, uuid) => {\n        workerUpdateBody({ uuid: uuid ?? passedUuid, data });\n      },\n      setAngle: (angle: number, uuid) => {\n        workerSetBody({\n          uuid: uuid ?? passedUuid,\n          method: 'setAngle',\n          methodParams: [angle],\n        });\n      },\n    };\n  }, [passedUuid]);\n\n  return api;\n};\n\nexport type BodyParams = {\n  syncBody?: boolean,\n  listenForCollisions?: boolean;\n  applyAngle?: boolean;\n  cacheKey?: string;\n  uuid?: ValidUUID;\n  fwdRef?: MutableRefObject<Object3D>;\n};\n\nexport const useBody = (\n  propsFn: () => AddBodyDef,\n  bodyParams: BodyParams = {}\n): [MutableRefObject<Object3D>, BodyApi, ValidUUID] => {\n  const {\n    applyAngle = false,\n    cacheKey,\n    uuid: passedUUID,\n    fwdRef,\n    listenForCollisions = false,\n    syncBody = true,\n  } = bodyParams;\n  const localRef = useRef<Object3D>((null as unknown) as Object3D);\n  const ref = fwdRef ? fwdRef : localRef;\n  const [uuid] = useState(() => {\n    if (passedUUID) return passedUUID;\n    if (!ref.current) {\n      ref.current = new Object3D();\n    }\n    return ref.current.uuid;\n  });\n  const [isDynamic] = useState(() => {\n    const props = propsFn();\n    return props.type !== BodyType.static;\n  });\n  const { workerAddBody, workerRemoveBody } = usePhysicsProvider();\n\n  useLayoutEffect(() => {\n    const props = propsFn();\n\n    if (!ref.current) {\n      ref.current = new Object3D()\n    }\n\n    const object = ref.current;\n\n    if (object) {\n      object.position.x = props.position?.x || 0;\n      object.position.y = props.position?.y || 0;\n    }\n\n    workerAddBody({\n      uuid,\n      listenForCollisions,\n      cacheKey,\n      ...props,\n    });\n\n    return () => {\n      workerRemoveBody({ uuid, cacheKey });\n    };\n  }, []);\n\n  useSubscribeMesh(uuid, ref, applyAngle, syncBody && isDynamic);\n\n  const api = useBodyApi(uuid);\n\n  return [ref, api, uuid];\n};\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\n\nexport type ContextState = {\n  subscribe: (callback: (event: MessageEvent) => void) => () => void;\n};\n\nexport const Context = createContext((null as unknown) as ContextState);\n\nexport const useWorkerOnMessage = () => {\n  return useContext(Context).subscribe;\n};\n\nconst WorkerOnMessageProvider: React.FC<{\n    subscribe: (callback: (event: MessageEvent) => void) => () => void;\n}> = ({ children, subscribe }) => {\n  return (\n    <Context.Provider\n      value={{\n        subscribe,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default WorkerOnMessageProvider;\n","import React, {\n  createContext,\n  FC,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n} from 'react';\nimport { PHYSICS_UPDATE_RATE } from '../main/worker/planckjs/config';\nimport { useWorkerOnMessage } from './WorkerOnMessageProvider';\nimport {\n  WorkerMessageType,\n  WorkerOwnerMessageType,\n} from '../main/worker/shared/types';\nimport { useStoredData } from './StoredPhysicsData';\nimport { useUpdateMeshes } from './MeshSubscriptions';\n\ntype State = {\n  onFixedUpdate: (callback: (delta: number) => void) => () => void;\n  getPhysicsStepTimeRemainingRatio: (time: number) => number;\n};\n\nconst Context = createContext((null as unknown) as State);\n\nexport const useGetPhysicsStepTimeRemainingRatio = () => {\n  return useContext(Context).getPhysicsStepTimeRemainingRatio;\n};\n\nexport const useFixedUpdate = (callback: (delta: number) => void) => {\n  const onFixedUpdate = useContext(Context).onFixedUpdate;\n\n  useEffect(() => {\n    const unsubscribe = onFixedUpdate(callback);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [onFixedUpdate, callback]);\n};\n\nconst PhysicsSync: FC<{\n  worker: Worker | MessagePort;\n  noLerping?: boolean;\n}> = ({ children, worker, noLerping = false }) => {\n  const lastUpdateRef = useRef(Date.now());\n  const countRef = useRef(0);\n  const callbacksRef = useRef<{\n    [key: string]: (delta: number) => void;\n  }>({});\n  const updateMeshes = useUpdateMeshes();\n\n  const getPhysicsStepTimeRemainingRatio = useCallback(\n    (previousTime: number) => {\n      const nextExpectedUpdate =\n        lastUpdateRef.current + PHYSICS_UPDATE_RATE + 1;\n      const time = Date.now();\n      let ratio = (time - previousTime) / (nextExpectedUpdate - previousTime);\n      ratio = ratio > 1 ? 1 : ratio;\n      ratio = ratio < 0 ? 0 : ratio;\n      return ratio;\n    },\n    [lastUpdateRef]\n  );\n\n  const onFixedUpdate = useCallback(\n    (callback: (delta: number) => void) => {\n      const key = countRef.current;\n      countRef.current += 1;\n\n      callbacksRef.current[key] = callback;\n\n      const unsubscribe = () => {\n        delete callbacksRef.current[key];\n      };\n\n      return unsubscribe;\n    },\n    [callbacksRef]\n  );\n\n  const onMessage = useWorkerOnMessage();\n  const storedData = useStoredData();\n\n  const debugRefs = useRef<{\n    timer: any;\n    hasReceived: boolean;\n  }>({\n    timer: null,\n    hasReceived: false,\n  });\n\n  useEffect(() => {\n    debugRefs.current.timer = setTimeout(() => {\n      console.warn('no initial physics data received...');\n    }, 1000);\n\n    const onPhysicsStep = () => {\n      const lastUpdate = lastUpdateRef.current;\n      const now = Date.now();\n      const delta = !lastUpdate ? 1 / 60 : (now - lastUpdate) / 1000;\n      lastUpdateRef.current = now;\n\n      const callbacks = callbacksRef.current;\n\n      Object.values(callbacks).forEach(callback => {\n        callback(delta);\n      });\n    };\n\n    const unsubscribe = onMessage((event: MessageEvent) => {\n      const type = event.data.type;\n\n      if (type === WorkerOwnerMessageType.PHYSICS_STEP) {\n        debugRefs.current.hasReceived = true;\n        if (debugRefs.current.timer) {\n          clearInterval(debugRefs.current.timer);\n        }\n        debugRefs.current.timer = setTimeout(() => {\n          console.warn('over 1 second since last physics step...');\n        }, 1000);\n        const positions = event.data.positions as Float32Array;\n        const angles = event.data.angles as Float32Array;\n        updateMeshes(positions, angles, noLerping);\n        worker.postMessage(\n          {\n            type: WorkerMessageType.PHYSICS_STEP_PROCESSED,\n            positions,\n            angles,\n            physicsTick: event.data.physicsTick as number,\n          },\n          [positions.buffer, angles.buffer]\n        );\n\n        if (event.data.bodies) {\n          storedData.bodies = event.data.bodies.reduce(\n            (acc: { [key: string]: number }, id: string) => ({\n              ...acc,\n              [id]: (event.data as any).bodies.indexOf(id),\n            }),\n            {}\n          );\n        }\n        onPhysicsStep();\n      }\n    });\n\n    worker.postMessage(\n        {\n          type: WorkerMessageType.READY_FOR_PHYSICS,\n        }\n    )\n\n    return () => {\n      unsubscribe();\n    };\n  }, [\n    onMessage,\n    callbacksRef,\n    lastUpdateRef,\n    worker,\n    updateMeshes,\n    noLerping,\n    storedData,\n  ]);\n\n  return (\n    <Context.Provider\n      value={{\n        onFixedUpdate,\n        getPhysicsStepTimeRemainingRatio,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default PhysicsSync;\n","export const PHYSICS_UPDATE_RATE = 1000 / 30;\n","import { useCallback, useEffect, useRef } from 'react';\n\nexport type Subscribe = (callback: (event: MessageEvent) => void) => () => void;\n\nexport const useWorkerMessages = (worker: undefined | Worker | MessagePort) => {\n  const idCount = useRef(0);\n  const subscriptionsRef = useRef<{\n    [key: string]: (event: MessageEvent) => void;\n  }>({});\n\n  const subscribe = useCallback(\n    (callback: (event: MessageEvent) => void) => {\n      const id = idCount.current;\n      idCount.current += 1;\n\n      subscriptionsRef.current[id] = callback;\n\n      return () => {\n        delete subscriptionsRef.current[id];\n      };\n    },\n    [subscriptionsRef]\n  );\n\n  useEffect(() => {\n    if (!worker) return;\n    const previousOnMessage = worker.onmessage;\n    worker.onmessage = (event: MessageEvent) => {\n      Object.values(subscriptionsRef.current).forEach(callback => {\n        callback(event);\n      });\n      if (previousOnMessage) {\n        (previousOnMessage as any)(event);\n      }\n    };\n  }, [worker, subscriptionsRef]);\n\n  return subscribe;\n};\n","import React, {\n  createContext,\n  FC,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport {PhysicsProps, WorkerMessageType, WorkerOwnerMessageType} from './worker/shared/types';\nimport WorkerOnMessageProvider from '../shared/WorkerOnMessageProvider';\nimport PhysicsSync from '../shared/PhysicsSync';\nimport StoredPhysicsData from '../shared/StoredPhysicsData';\nimport MeshSubscriptions from '../shared/MeshSubscriptions';\nimport PhysicsProvider from '../shared/PhysicsProvider';\nimport {useWorkerMessages} from \"./hooks/useWorkerMessages\";\n\ntype ContextState = {\n  worker: Worker;\n};\n\nconst Context = createContext((null as unknown) as ContextState);\n\nexport const usePhysicsWorker = () => {\n  return useContext(Context).worker;\n};\n\nconst PhysicsWorker: FC<PhysicsProps & {\n  physicsWorker: Worker,\n}> = ({ children, physicsWorker, config, worldParams }) => {\n\n  const worker = physicsWorker\n\n  const [initiated, setInitiated] = useState(false)\n\n  useEffect(() => {\n    worker.postMessage({\n      type: WorkerMessageType.INIT,\n      props: {\n        config,\n        worldParams,\n      },\n    });\n  }, [worker]);\n\n  const subscribe = useWorkerMessages(worker)\n\n  useEffect(() => {\n\n    const unsubscribe = subscribe((event) => {\n\n      const type = event.data.type;\n\n      if (type === WorkerOwnerMessageType.INITIATED) {\n        setInitiated(true)\n      }\n\n      return () => {\n        unsubscribe()\n      }\n    })\n\n  }, [subscribe, setInitiated])\n\n  if (!initiated) return null\n\n  return (\n    <Context.Provider\n      value={{\n        worker,\n      }}\n    >\n      <PhysicsProvider worker={worker}>\n        <StoredPhysicsData>\n          <MeshSubscriptions>\n            <WorkerOnMessageProvider subscribe={subscribe}>\n              <PhysicsSync worker={worker}>{children}</PhysicsSync>\n            </WorkerOnMessageProvider>\n          </MeshSubscriptions>\n        </StoredPhysicsData>\n      </PhysicsProvider>\n    </Context.Provider>\n  );\n};\n\nexport default PhysicsWorker;\n","import React, { useCallback } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { useGetPhysicsStepTimeRemainingRatio } from '../shared/PhysicsSync';\nimport { useLerpMeshes } from '../shared/MeshSubscriptions';\n\nconst R3FPhysicsObjectUpdater: React.FC = ({ children }) => {\n  const getPhysicsStepTimeRemainingRatio = useGetPhysicsStepTimeRemainingRatio();\n  const lerpMeshes = useLerpMeshes();\n\n  const onFrame = useCallback(() => {\n    lerpMeshes(getPhysicsStepTimeRemainingRatio);\n  }, [getPhysicsStepTimeRemainingRatio, lerpMeshes]);\n\n  useFrame(onFrame);\n\n  return <>{children}</>;\n};\n\nexport default R3FPhysicsObjectUpdater;\n","import React, {createContext, useCallback, useContext, useEffect, useState} from 'react';\nimport {ValidUUID, WorkerOwnerMessageType} from '../main/worker/shared/types';\nimport { CollisionEventProps } from '../main/worker/planckjs/data';\nimport {useWorkerOnMessage} from \"./WorkerOnMessageProvider\";\n\ntype CollisionsProviderContextState = {\n  addCollisionHandler: (\n    started: boolean,\n    uuid: ValidUUID,\n    callback: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void\n  ) => void;\n  removeCollisionHandler: (started: boolean, uuid: ValidUUID) => void;\n  handleBeginCollision: (data: CollisionEventProps) => void;\n  handleEndCollision: (data: CollisionEventProps) => void;\n};\n\nconst CollisionsProviderContext = createContext(\n  (null as unknown) as CollisionsProviderContextState\n);\n\nexport const useCollisionsProviderContext = (): CollisionsProviderContextState => {\n  return useContext(CollisionsProviderContext);\n};\n\nconst CollisionsProvider: React.FC = ({ children }) => {\n  const [collisionStartedEvents] = useState<{\n    [key: string]: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void;\n  }>({});\n\n  const [collisionEndedEvents] = useState<{\n    [key: string]: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void;\n  }>({});\n\n  const addCollisionHandler = useCallback(\n    (\n      started: boolean,\n      uuid: ValidUUID,\n      callback: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void\n    ) => {\n      if (started) {\n        collisionStartedEvents[uuid] = callback;\n      } else {\n        collisionEndedEvents[uuid] = callback;\n      }\n    },\n    []\n  );\n\n  const removeCollisionHandler = useCallback(\n    (started: boolean, uuid: ValidUUID) => {\n      if (started) {\n        delete collisionStartedEvents[uuid];\n      } else {\n        delete collisionEndedEvents[uuid];\n      }\n    },\n    []\n  );\n\n  const handleBeginCollision = useCallback(\n    (data: CollisionEventProps) => {\n      if (collisionStartedEvents[data.uuid]) {\n        collisionStartedEvents[data.uuid](\n          data.data,\n          data.fixtureIndex,\n          data.collidedFixtureIndex,\n          data.isSensor\n        );\n      }\n    },\n    [collisionStartedEvents]\n  );\n\n  const handleEndCollision = useCallback(\n    (data: CollisionEventProps) => {\n      if (collisionEndedEvents[data.uuid]) {\n        collisionEndedEvents[data.uuid](\n          data.data,\n          data.fixtureIndex,\n          data.collidedFixtureIndex,\n          data.isSensor\n        );\n      }\n    },\n    [collisionEndedEvents]\n  );\n\n  const onMessage = useWorkerOnMessage();\n\n  useEffect(() => {\n\n      const unsubscribe = onMessage((event: MessageEvent) => {\n          const type = event.data.type;\n\n          switch (type) {\n              case WorkerOwnerMessageType.BEGIN_COLLISION:\n                handleBeginCollision(event.data.props as any)\n                break;\n              case WorkerOwnerMessageType.END_COLLISION:\n                handleEndCollision(event.data.props as any)\n                break;\n              default:\n          }\n\n      })\n\n      return unsubscribe\n\n  }, [])\n\n  return (\n    <CollisionsProviderContext.Provider\n      value={{\n        addCollisionHandler,\n        removeCollisionHandler,\n        handleBeginCollision,\n        handleEndCollision,\n      }}\n    >\n      {children}\n    </CollisionsProviderContext.Provider>\n  );\n};\n\nexport default CollisionsProvider;\n","import React, {createContext, useCallback, useContext, useEffect, useMemo, useState} from \"react\"\nimport {Object3D} from \"three\";\n\ntype MeshRefsContextState = {\n    meshes: {\n        [key: string]: Object3D,\n    },\n    addMesh: (uuid: string, mesh: Object3D) => () => void,\n}\n\nconst MeshRefsContext = createContext(null as unknown as MeshRefsContextState)\n\nexport const useStoreMesh = (uuid: string, mesh: Object3D) => {\n    const addMesh = useContext(MeshRefsContext).addMesh\n\n    useEffect(() => {\n\n        const remove = addMesh(uuid, mesh)\n\n        return () => {\n            remove()\n        }\n\n    }, [addMesh, uuid, mesh])\n\n}\n\nexport const useStoredMesh = (uuid: string): Object3D | null => {\n    const meshes = useContext(MeshRefsContext).meshes\n\n    const mesh = useMemo(() => {\n        return meshes[uuid] ?? null\n    }, [uuid, meshes])\n\n    return mesh\n}\n\nconst MeshRefs: React.FC = ({children}) => {\n\n    const [meshes, setMeshes] = useState<{\n        [key: string]: Object3D,\n    }>({})\n\n    const addMesh = useCallback((uuid: string, mesh: Object3D) => {\n\n        setMeshes(state => {\n            return {\n                ...state,\n                [uuid]: mesh,\n            }\n        })\n\n        const removeMesh = () => {\n            setMeshes(state => {\n                const updated = {\n                    ...state,\n                }\n                delete updated[uuid]\n                return updated\n            })\n        }\n\n        return removeMesh\n\n    }, [setMeshes])\n\n    return (\n        <MeshRefsContext.Provider value={{\n            meshes,\n            addMesh,\n        }}>\n            {children}\n        </MeshRefsContext.Provider>\n    )\n}\n\nexport default MeshRefs","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useRef,\n  useState,\n} from 'react';\nimport { MessageData } from './types';\n\ntype MessagesContextState = {\n  handleMessage: (message: MessageData) => void;\n  subscribeToMessage: (\n    messageKey: string,\n    callback: (data: any) => void\n  ) => () => void;\n};\n\nconst MessagesContext = createContext(\n  (null as unknown) as MessagesContextState\n);\n\nexport const useMessagesContext = () => {\n  return useContext(MessagesContext);\n};\n\nexport const useOnMessage = () => {\n  return useMessagesContext().subscribeToMessage;\n};\n\nconst Messages: React.FC = ({ children }) => {\n  const messageCountRef = useRef(0);\n  const [messageSubscriptions] = useState<{\n    [key: string]: {\n      [id: number]: (data: any) => void;\n    };\n  }>({});\n\n  const subscribeToMessage = useCallback(\n    (messageKey: string, callback: (data: any) => void) => {\n      const id = messageCountRef.current;\n      messageCountRef.current += 1;\n\n      if (!messageSubscriptions[messageKey]) {\n        messageSubscriptions[messageKey] = {\n          [id]: callback,\n        };\n      } else {\n        messageSubscriptions[messageKey][id] = callback;\n      }\n\n      const unsubscribe = () => {\n        delete messageSubscriptions[messageKey][id];\n      };\n\n      return unsubscribe;\n    },\n    [messageSubscriptions]\n  );\n\n  const handleMessage = useCallback(\n    ({ key, data }: MessageData) => {\n\n      const subscriptions = messageSubscriptions[key];\n\n      if (subscriptions) {\n        Object.values(subscriptions).forEach(subscription => {\n          subscription(data);\n        });\n      }\n    },\n    [messageSubscriptions]\n  );\n\n  return (\n    <MessagesContext.Provider\n      value={{\n        handleMessage,\n        subscribeToMessage,\n      }}\n    >\n      {children}\n    </MessagesContext.Provider>\n  );\n};\n\nexport default Messages;\n","import React, { useEffect, useState } from 'react';\nimport { useOnMessage } from '../shared/Messages';\nimport {\n  MappedComponents,\n  MessageKeys,\n  SyncComponentMessage,\n  SyncComponentMessageType,\n  SyncComponentType,\n  ValidProps,\n} from '../shared/types';\n\nconst LogicHandler: React.FC<{\n  mappedComponentTypes: MappedComponents;\n}> = ({ children, mappedComponentTypes }) => {\n  const subscribeToMessage = useOnMessage();\n\n  const [components, setComponents] = useState<{\n    [key: string]: {\n      componentType: SyncComponentType;\n      props: ValidProps;\n    };\n  }>({});\n\n  useEffect(() => {\n    const unsubscribe = subscribeToMessage(\n      MessageKeys.SYNC_COMPONENT,\n      ({ info, messageType, data }: SyncComponentMessage) => {\n        const props = data || {};\n\n        switch (messageType) {\n          case SyncComponentMessageType.MOUNT:\n            setComponents(state => {\n              return {\n                ...state,\n                [info.componentKey]: {\n                  componentType: info.componentType,\n                  props,\n                },\n              };\n            });\n            break;\n          case SyncComponentMessageType.UPDATE:\n            setComponents(state => {\n              const previousData = state[info.componentKey]\n              const previousProps = previousData && previousData.props ? previousData.props : {}\n              return {\n                ...state,\n                [info.componentKey]: {\n                  componentType: info.componentType,\n                  props: {\n                    ...previousProps,\n                    ...props,\n                  },\n                },\n              };\n            });\n            break;\n          case SyncComponentMessageType.UNMOUNT:\n            setComponents(state => {\n              let update = {\n                ...state,\n              };\n              delete update[info.componentKey];\n              return update;\n            });\n            break;\n        }\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return (\n    <>\n      {children}\n      {Object.entries(components).map(([key, { componentType, props }]) => {\n        const Component = mappedComponentTypes[componentType];\n        return Component ? <Component key={key} {...props} /> : null;\n      })}\n    </>\n  );\n};\n\nexport default LogicHandler;\n","import React, {createContext, useCallback, useContext} from \"react\"\nimport {WorkerOwnerMessageType} from \"../main/worker/shared/types\";\nimport {MessageData, MessageKeys} from \"./types\";\nimport {useMessagesContext} from \"./Messages\";\n\ntype ContextState = {\n    sendMessage: (key: string, data: any) => void,\n}\n\nconst Context = createContext(null as unknown as ContextState)\n\nexport const useSendMessage = () => {\n    return useContext(Context).sendMessage\n}\n\nconst SendMessages: React.FC<{\n    worker: Worker,\n}> = ({children, worker}) => {\n\n    const { handleMessage } = useMessagesContext();\n\n    const sendMessage = useCallback((key: string, data: any) => {\n\n        if (key === MessageKeys.SYNC_COMPONENT) {\n            throw new Error(`${key} is a reserved message key.`)\n        }\n\n        const message: MessageData = {\n            key,\n            data\n        }\n\n        worker.postMessage({\n            type: WorkerOwnerMessageType.MESSAGE,\n            message,\n        })\n\n        handleMessage(message)\n\n    }, [worker, handleMessage])\n\n    return (\n        <Context.Provider value={{sendMessage}}>\n            {children}\n        </Context.Provider>\n    )\n}\n\nexport default SendMessages","import React, { useEffect } from 'react';\nimport { usePhysicsWorker } from './PhysicsWorker';\nimport {\n  WorkerMessageType,\n  WorkerOwnerMessageType,\n} from './worker/shared/types';\nimport { MappedComponents, MessageData } from '../shared/types';\nimport Messages, { useMessagesContext } from '../shared/Messages';\nimport LogicHandler from './LogicHandler';\nimport SendMessages from \"../shared/SendMessages\";\n\nconst LogicWorkerInner: React.FC<{\n  worker: Worker;\n}> = ({ children, worker }) => {\n  const physicsWorker = usePhysicsWorker();\n\n  const { handleMessage } = useMessagesContext();\n\n  useEffect(() => {\n    const channel = new MessageChannel();\n    physicsWorker.postMessage({ command: 'connect' }, [channel.port1]);\n    worker.postMessage({ command: 'connect' }, [channel.port2]);\n\n    worker.onmessage = (event: MessageEvent) => {\n      const type = event.data.type;\n\n      switch (type) {\n        case WorkerOwnerMessageType.MESSAGE:\n          handleMessage(event.data.message as MessageData);\n          break;\n      }\n    };\n\n    worker.postMessage({\n      type: WorkerMessageType.INIT,\n    });\n  }, [worker, physicsWorker]);\n\n  return <>{children}</>;\n};\n\nexport const LogicWorker: React.FC<{\n  worker: Worker;\n  logicMappedComponents: MappedComponents;\n}> = ({ worker, children, logicMappedComponents }) => {\n  return (\n    <Messages>\n      <SendMessages worker={worker}>\n        <LogicWorkerInner worker={worker}>\n          <LogicHandler mappedComponentTypes={logicMappedComponents}>\n            {children}\n          </LogicHandler>\n        </LogicWorkerInner>\n      </SendMessages>\n    </Messages>\n  );\n};\n","import React from 'react';\nimport StoredPhysicsData from '../../shared/StoredPhysicsData';\nimport MeshSubscriptions from '../../shared/MeshSubscriptions';\nimport WorkerOnMessageProvider from '../../shared/WorkerOnMessageProvider';\nimport PhysicsSync from '../../shared/PhysicsSync';\nimport PhysicsProvider from '../../shared/PhysicsProvider';\nimport {useWorkerMessages} from \"../../main/hooks/useWorkerMessages\";\n\nconst PhysicsHandler: React.FC<{\n  worker: null | Worker | MessagePort;\n}> = ({ children, worker }) => {\n  if (!worker) return null;\n\n  const subscribe = useWorkerMessages(worker)\n\n  return (\n    <PhysicsProvider worker={worker}>\n      <WorkerOnMessageProvider subscribe={subscribe}>\n        <StoredPhysicsData>\n          <MeshSubscriptions>\n            <PhysicsSync worker={worker} noLerping>\n              {children}\n            </PhysicsSync>\n          </MeshSubscriptions>\n        </StoredPhysicsData>\n      </WorkerOnMessageProvider>\n    </PhysicsProvider>\n  );\n};\n\nexport default PhysicsHandler;\n","import React, {useEffect} from \"react\"\nimport {useMessagesContext} from \"../../shared/Messages\";\nimport {WorkerOwnerMessageType} from \"../../main/worker/shared/types\";\nimport {MessageData} from \"../../shared/types\";\n\nconst MessageHandler: React.FC<{\n    worker: Worker,\n}> = ({children, worker}) => {\n\n    const { handleMessage } = useMessagesContext();\n\n    useEffect(() => {\n\n        worker.onmessage = (event: MessageEvent) => {\n            const type = event.data.type;\n\n            switch (type) {\n                case WorkerOwnerMessageType.MESSAGE:\n                    handleMessage(event.data.message as MessageData);\n                    break;\n            }\n        };\n    }, [worker]);\n\n    return (\n        <>\n            {children}\n        </>\n    )\n}\n\nexport default MessageHandler","import React, {createContext, useContext} from 'react';\nimport {MessageData} from \"../shared/types\";\nimport PhysicsHandler from \"./logicWorkerApp/PhysicsHandler\";\nimport CollisionsProvider from \"../shared/CollisionsProvider\";\nimport MeshRefs from \"../main/MeshRefs\";\nimport Messages from \"../shared/Messages\";\nimport SendMessages from \"../shared/SendMessages\";\nimport MessageHandler from \"./logicWorkerApp/MessageHandler\";\n\nexport type ContextState = {\n  physicsWorker: Worker | MessagePort;\n  sendMessageToMain: (message: MessageData) => void;\n};\n\nexport const Context = createContext((null as unknown) as ContextState);\n\nexport const useWorkerAppContext = (): ContextState => {\n  return useContext(Context);\n};\n\nexport const useSendMessageToMain = () => {\n  return useWorkerAppContext().sendMessageToMain;\n};\n\nconst ApiWrapper: React.FC<{\n  worker: Worker,\n  physicsWorker: Worker | MessagePort,\n  sendMessageToMain: (message: MessageData) => void,\n}> = ({\n  children,\n  worker,\n  physicsWorker,\n  sendMessageToMain\n}) => {\n  return (\n      <Context.Provider value={{ physicsWorker, sendMessageToMain }}>\n        <Messages>\n          <MessageHandler worker={worker}>\n            <SendMessages worker={worker}>\n              <MeshRefs>\n                <PhysicsHandler worker={physicsWorker}>\n                  <CollisionsProvider>\n                      {children}\n                  </CollisionsProvider>\n                </PhysicsHandler>\n              </MeshRefs>\n            </SendMessages>\n          </MessageHandler>\n        </Messages>\n      </Context.Provider>\n  );\n};\n\nexport default ApiWrapper;\n\nexport const withLogicWrapper = (WrappedComponent: any) => {\n  return (props: any) => {\n    return (\n      <ApiWrapper {...props}>\n        <WrappedComponent />\n      </ApiWrapper>\n    );\n  };\n};\n","import { useCallback } from 'react';\nimport {\n  MessageKeys,\n  SyncComponentMessageInfo,\n  SyncComponentMessageType,\n} from '../../../shared/types';\nimport {useSendMessageToMain} from \"../../ApiWrapper\";\n\nexport const useSendSyncComponentMessage = () => {\n  const sendMessageRaw = useSendMessageToMain();\n\n  const sendMessage = useCallback(\n    (\n      messageType: SyncComponentMessageType,\n      info: SyncComponentMessageInfo,\n      data?: any\n    ) => {\n      sendMessageRaw({\n        key: MessageKeys.SYNC_COMPONENT,\n        data: {\n          messageType,\n          info,\n          data,\n        },\n      });\n    },\n    [sendMessageRaw]\n  );\n\n  return sendMessage;\n};\n","import React, {MutableRefObject, ReactElement, useRef} from \"react\"\nimport {ValidUUID} from \"./worker/shared/types\";\nimport {Object3D} from \"three\";\nimport {BodyApi, BodyParams, useBody, useBodyApi} from \"./hooks/useBody\";\nimport {AddBodyDef} from \"./worker/planckjs/bodies\";\nimport { useSubscribeMesh } from \"../shared/MeshSubscriptions\";\n\nexport const BodySync: React.FC<{\n    children: ({uuid, ref, api}: {uuid: ValidUUID, ref: MutableRefObject<Object3D>, api?: BodyApi}) => ReactElement,\n    uuid: ValidUUID,\n    applyAngle?: boolean,\n    isDynamic?: boolean,\n    bodyRef?: MutableRefObject<Object3D>,\n    wrapWithGroup?: boolean,\n}> = ({\n     children,\n     uuid,\n     bodyRef,\n     applyAngle = true,\n     isDynamic = true,\n     wrapWithGroup = false,\n }) => {\n\n    const localRef = useRef<Object3D>(new Object3D())\n\n    const ref = bodyRef ?? localRef\n\n    useSubscribeMesh(uuid, ref, applyAngle, isDynamic)\n\n    const api = useBodyApi(uuid)\n\n    const inner = children({uuid, ref, api: api ?? undefined})\n\n    if (wrapWithGroup) {\n        return (\n            <group ref={ref}>\n                {inner}\n            </group>\n        )\n    }\n\n    return inner\n\n}\n\nexport const Body: React.FC<{\n    children: ({uuid, ref, api}: {uuid: ValidUUID, ref: MutableRefObject<Object3D>, api: BodyApi}) => ReactElement,\n    bodyDef: AddBodyDef,\n    params?: BodyParams,\n    wrapWithGroup?: boolean,\n}> = ({children, params, bodyDef, wrapWithGroup}) => {\n\n    const [ref, api, uuid] = useBody(() => bodyDef, params)\n\n    const inner = children({ref, uuid, api})\n\n    if (wrapWithGroup) {\n        return (\n            <group ref={ref}>\n                {inner}\n            </group>\n        )\n    }\n\n    return inner\n}\n","import React, { FC } from 'react';\nimport PhysicsWorker from './PhysicsWorker';\nimport R3FPhysicsObjectUpdater from './R3FPhysicsObjectUpdater';\nimport CollisionsProvider from '../shared/CollisionsProvider';\nimport { MappedComponents } from '../shared/types';\nimport MeshRefs from \"./MeshRefs\";\nimport {PhysicsProps} from \"./worker/shared/types\";\nimport {LogicWorker} from \"./LogicWorker\";\n\nexport const Engine: FC<PhysicsProps & {\n  physicsWorker: Worker,\n  logicWorker?: Worker;\n  logicMappedComponents?: MappedComponents;\n}> = ({\n  children,\n  physicsWorker,\n  config,\n  worldParams,\n  logicWorker,\n  logicMappedComponents = {},\n}) => {\n  if (logicWorker) {\n    return (\n      <MeshRefs>\n        <PhysicsWorker physicsWorker={physicsWorker} config={config} worldParams={worldParams}>\n          <CollisionsProvider>\n            <R3FPhysicsObjectUpdater>\n              <LogicWorker\n                worker={logicWorker}\n                logicMappedComponents={logicMappedComponents}\n              >\n                  {children}\n              </LogicWorker>\n            </R3FPhysicsObjectUpdater>\n          </CollisionsProvider>\n        </PhysicsWorker>\n      </MeshRefs>\n    );\n  }\n\n  return (\n    <MeshRefs>\n      <PhysicsWorker physicsWorker={physicsWorker} config={config} worldParams={worldParams}>\n        <CollisionsProvider>\n          <R3FPhysicsObjectUpdater>\n              {children}\n          </R3FPhysicsObjectUpdater>\n        </CollisionsProvider>\n      </PhysicsWorker>\n    </MeshRefs>\n  );\n};\n","import { render } from 'react-nil';\nimport { createElement, FC } from 'react';\nimport { proxy } from 'valtio';\nimport { WorkerMessageType } from '../main/worker/shared/types';\n\nexport const logicWorkerHandler = (selfWorker: Worker, app: FC) => {\n  let physicsWorkerPort: MessagePort;\n\n  const state = proxy<{\n    physicsWorkerLoaded: boolean;\n    initiated: boolean;\n  }>({\n    physicsWorkerLoaded: false,\n    initiated: false,\n  });\n\n  const workerRef: {\n    physicsWorker: null | Worker | MessagePort;\n  } = {\n    physicsWorker: null,\n  };\n\n  selfWorker.onmessage = (event: MessageEvent) => {\n    switch (event.data.command) {\n      case 'connect':\n        physicsWorkerPort = event.ports[0];\n        workerRef.physicsWorker = physicsWorkerPort;\n        state.physicsWorkerLoaded = true;\n        return;\n\n      case 'forward':\n        physicsWorkerPort.postMessage(event.data.message);\n        return;\n    }\n\n    const { type, props = {} } = event.data as {\n      type: WorkerMessageType;\n      props: any;\n    };\n\n    switch (type) {\n      case WorkerMessageType.INIT:\n        state.initiated = true;\n        break;\n    }\n  };\n  render(\n    createElement(\n      require('./logicWorkerApp/index').WorkerApp,\n      {\n        worker: selfWorker,\n        state,\n        workerRef,\n        app,\n      },\n      null\n    )\n  );\n};\n","import {createElement, FC} from \"react\";\nimport {PhysicsProps, WorkerMessageType} from \"./shared/types\";\nimport {render} from \"react-nil\";\n\nexport const physicsWorkerHandler = (selfWorker: Worker) => {\n\n    selfWorker.onmessage = (event: MessageEvent) => {\n        const { type, props = {} } = event.data as {\n            type: WorkerMessageType;\n            props: any;\n        };\n        switch (type) {\n            case WorkerMessageType.INIT:\n                const { worldParams = {}, config = {} } = props as PhysicsProps;\n                const {\n                    maxNumberOfDynamicObjects = 100,\n                    updateRate = 1000 / 30,\n                } = config;\n                render(\n                    createElement(\n                        require('./worker/app/index').App,\n                        {\n                            worker: selfWorker,\n                            config: {\n                                maxNumberOfDynamicObjects,\n                                updateRate,\n                            },\n                            worldParams,\n                        },\n                        null\n                    )\n                );\n                break;\n        }\n    };\n};","import {ValidUUID} from \"../worker/shared/types\";\nimport {useCollisionsProviderContext} from \"../../shared/CollisionsProvider\";\nimport {useEffect} from \"react\";\n\nexport const useCollisionEvents = (\n    uuid: ValidUUID,\n    onCollideStart?: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void,\n    onCollideEnd?: (data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => void,\n) => {\n\n    const {\n        addCollisionHandler,\n        removeCollisionHandler\n    } = useCollisionsProviderContext()\n\n    // @ts-ignore\n    useEffect(() => {\n        if (onCollideStart) {\n            addCollisionHandler(true, uuid, onCollideStart)\n            return () => {\n                removeCollisionHandler(true, uuid)\n            }\n        }\n    }, [uuid, onCollideStart])\n\n    // @ts-ignore\n    useEffect(() => {\n        if (onCollideEnd) {\n            addCollisionHandler(false, uuid, onCollideEnd)\n            return () => {\n                removeCollisionHandler(false, uuid)\n            }\n        }\n    }, [uuid, onCollideEnd])\n\n}\n","import { useCallback, useEffect, useMemo } from 'react';\nimport {\n  SyncComponentMessageType,\n  SyncComponentType,\n} from '../../../shared/types';\nimport { useSendSyncComponentMessage } from './messaging';\n\nexport const useSyncWithMainComponent = (\n  componentType: SyncComponentType,\n  componentKey: string,\n  initialProps?: any\n) => {\n  const sendMessage = useSendSyncComponentMessage();\n\n  const info = useMemo(\n    () => ({\n      componentType,\n      componentKey,\n    }),\n    [componentType, componentKey]\n  );\n\n  const updateProps = useCallback(\n    (props: any) => {\n      sendMessage(SyncComponentMessageType.UPDATE, info, props);\n    },\n    [info]\n  );\n\n  useEffect(() => {\n    sendMessage(SyncComponentMessageType.MOUNT, info, initialProps);\n\n    return () => {\n      sendMessage(SyncComponentMessageType.UNMOUNT, info);\n    };\n  }, [info]);\n\n  return updateProps;\n};\n"],"names":["WorkerMessageType","WorkerOwnerMessageType","BodyType","BodyShape","MessageKeys","SyncComponentMessageType","SyncComponentType","Context","createContext","usePhysicsProvider","useContext","PhysicsProvider","children","worker","workerAddBody","useCallback","props","postMessage","type","ADD_BODY","workerRemoveBody","REMOVE_BODY","workerSetBody","SET_BODY","workerUpdateBody","UPDATE_BODY","React","Provider","value","useStoredData","data","StoredPhysicsData","useState","bodies","lerp","MathUtils","useSubscribeMesh","uuid","objectRef","applyAngle","isDynamic","addSubscription","useEffect","unsubscribe","MeshSubscriptions","subscriptionsRef","useRef","lerpMeshes","getPhysicsStepTimeRemainingRatio","Object","values","current","forEach","target","lastUpdate","object","position","angle","physicsRemainingRatio","Date","now","x","y","rotation","z","storedData","updateMeshes","positions","angles","immediate","entries","update","buffers","index","undefined","length","start","slice","getPositionAndAngle","useBodyApi","passedUuid","useMemo","applyForceToCenter","vec","method","methodParams","applyLinearImpulse","pos","setPosition","setAwake","flag","setLinearVelocity","updateBody","setAngle","useBody","propsFn","bodyParams","cacheKey","passedUUID","fwdRef","listenForCollisions","syncBody","localRef","ref","Object3D","useLayoutEffect","api","useWorkerOnMessage","subscribe","WorkerOnMessageProvider","PhysicsSync","noLerping","lastUpdateRef","countRef","callbacksRef","previousTime","nextExpectedUpdate","ratio","onFixedUpdate","callback","key","onMessage","debugRefs","timer","hasReceived","setTimeout","console","warn","event","delta","PHYSICS_STEP","clearInterval","PHYSICS_STEP_PROCESSED","physicsTick","buffer","reduce","acc","id","indexOf","READY_FOR_PHYSICS","useWorkerMessages","idCount","previousOnMessage","onmessage","PhysicsWorker","config","worldParams","physicsWorker","initiated","setInitiated","INIT","INITIATED","R3FPhysicsObjectUpdater","onFrame","useFrame","CollisionsProviderContext","CollisionsProvider","collisionStartedEvents","collisionEndedEvents","addCollisionHandler","started","removeCollisionHandler","handleBeginCollision","fixtureIndex","collidedFixtureIndex","isSensor","handleEndCollision","BEGIN_COLLISION","END_COLLISION","MeshRefsContext","MeshRefs","meshes","setMeshes","addMesh","mesh","state","updated","MessagesContext","useMessagesContext","useOnMessage","subscribeToMessage","Messages","messageCountRef","messageSubscriptions","messageKey","handleMessage","subscriptions","subscription","LogicHandler","mappedComponentTypes","components","setComponents","SYNC_COMPONENT","info","messageType","MOUNT","componentKey","componentType","UPDATE","previousData","UNMOUNT","map","Component","SendMessages","sendMessage","Error","message","MESSAGE","LogicWorkerInner","channel","MessageChannel","command","port1","port2","LogicWorker","logicMappedComponents","PhysicsHandler","MessageHandler","ApiWrapper","sendMessageToMain","useSendSyncComponentMessage","sendMessageRaw","bodyDef","wrapWithGroup","params","inner","bodyRef","logicWorker","width","height","center","fixtureOptions","fixture","shape","box","hx","hy","radius","circle","selfWorker","app","physicsWorkerPort","proxy","physicsWorkerLoaded","workerRef","ports","render","createElement","require","WorkerApp","maxNumberOfDynamicObjects","updateRate","App","onCollideStart","onCollideEnd","remove","initialProps","updateProps","WrappedComponent"],"mappings":"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"}