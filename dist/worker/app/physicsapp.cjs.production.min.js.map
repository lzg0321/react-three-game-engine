{"version":3,"file":"physicsapp.cjs.production.min.js","sources":["../src/main/worker/app/appContext.ts","../src/main/worker/shared/types.ts","../src/main/hooks/useWorkerMessages.ts","../src/main/worker/planckjs/collisions/collisions.ts","../src/main/worker/planckjs/bodies.ts","../src/main/worker/app/WorldState.tsx","../src/main/worker/app/Bodies.tsx","../src/main/worker/app/buffers.ts","../src/main/worker/app/World.tsx","../src/main/worker/app/Collisions.tsx","../src/main/worker/app/index.tsx","../src/main/worker/app/logicWorker.ts"],"sourcesContent":["import { createContext, MutableRefObject, useContext } from 'react';\nimport { World } from 'planck-js';\nimport { Subscribe } from '../../hooks/useWorkerMessages';\nimport { Buffers } from '../shared/types';\n\nexport type AppContextState = {\n  updateRate: number;\n  world: World;\n  worker: Worker;\n  logicWorker?: Worker | MessagePort;\n  subscribe: Subscribe;\n  logicSubscribe: Subscribe;\n  buffers: Buffers;\n  logicBuffers: Buffers;\n  buffersRef: MutableRefObject<{\n    mainCount: number;\n    logicCount: number;\n  }>;\n  maxNumberOfDynamicObjects: number;\n};\n\nexport const AppContext = createContext((null as unknown) as AppContextState);\n\nexport const useWorld = (): World => {\n  return useContext(AppContext).world;\n};\n\nexport const useAppContext = (): AppContextState => {\n  return useContext(AppContext);\n};\n","import { WorldDef } from 'planck-js';\n\nexport enum WorkerMessageType {\n  INIT,\n  STEP,\n  LOGIC_FRAME,\n  ADD_BODY,\n  REMOVE_BODY,\n  SET_BODY,\n  UPDATE_BODY,\n  PHYSICS_STEP_PROCESSED,\n  READY_FOR_PHYSICS,\n}\n\nexport enum WorkerOwnerMessageType {\n  FRAME,\n  PHYSICS_STEP,\n  SYNC_BODIES,\n  BEGIN_COLLISION,\n  END_COLLISION,\n  MESSAGE,\n  INITIATED,\n}\n\nexport type Buffers = {\n  positions: Float32Array;\n  angles: Float32Array;\n};\n\nexport type ValidUUID = string | number;\n\nexport type PhysicsProps = {\n  config?: {\n    maxNumberOfDynamicObjects?: number;\n    updateRate?: number;\n  };\n  worldParams?: WorldDef;\n};\n","import { useCallback, useEffect, useRef } from 'react';\n\nexport type Subscribe = (callback: (event: MessageEvent) => void) => () => void;\n\nexport const useWorkerMessages = (worker: undefined | Worker | MessagePort) => {\n  const idCount = useRef(0);\n  const subscriptionsRef = useRef<{\n    [key: string]: (event: MessageEvent) => void;\n  }>({});\n\n  const subscribe = useCallback(\n    (callback: (event: MessageEvent) => void) => {\n      const id = idCount.current;\n      idCount.current += 1;\n\n      subscriptionsRef.current[id] = callback;\n\n      return () => {\n        delete subscriptionsRef.current[id];\n      };\n    },\n    [subscriptionsRef]\n  );\n\n  useEffect(() => {\n    if (!worker) return;\n    const previousOnMessage = worker.onmessage;\n    worker.onmessage = (event: MessageEvent) => {\n      Object.values(subscriptionsRef.current).forEach(callback => {\n        callback(event);\n      });\n      if (previousOnMessage) {\n        (previousOnMessage as any)(event);\n      }\n    };\n  }, [worker, subscriptionsRef]);\n\n  return subscribe;\n};\n","import { Fixture } from 'planck-js';\nimport { FixtureUserData } from './types';\nimport { activeCollisionListeners } from './data';\nimport {\n  sendCollisionBeginEvent,\n  sendCollisionEndEvent,\n} from '../../functions';\n\nexport const getFixtureData = (fixture: Fixture): FixtureUserData | null => {\n  const userData = fixture.getUserData() as null | FixtureUserData;\n  return userData || null;\n};\n\nexport const getFixtureUuid = (data: FixtureUserData | null): string => {\n  if (data && data['uuid']) {\n    return data.uuid;\n  }\n  return '';\n};\n\nexport const getFixtureIndex = (data: FixtureUserData | null): number => {\n  if (data) {\n    return data.fixtureIndex;\n  }\n  return -1;\n};\n\nexport const handleBeginCollision = (fixtureA: Fixture, fixtureB: Fixture) => {\n  const aData = getFixtureData(fixtureA);\n  const bData = getFixtureData(fixtureB);\n  const aUUID = getFixtureUuid(aData);\n  const bUUID = getFixtureUuid(bData);\n\n  if (aUUID && activeCollisionListeners[aUUID]) {\n    sendCollisionBeginEvent(\n      aUUID,\n      bData,\n      getFixtureIndex(aData),\n      fixtureB.isSensor()\n    );\n  }\n\n  if (bUUID && activeCollisionListeners[bUUID]) {\n    sendCollisionBeginEvent(\n      bUUID,\n      aData,\n      getFixtureIndex(bData),\n      fixtureA.isSensor()\n    );\n  }\n};\n\nexport const handleEndCollision = (fixtureA: Fixture, fixtureB: Fixture) => {\n  const aData = getFixtureData(fixtureA);\n  const bData = getFixtureData(fixtureB);\n  const aUUID = getFixtureUuid(aData);\n  const bUUID = getFixtureUuid(bData);\n\n  if (aUUID && activeCollisionListeners[aUUID]) {\n    sendCollisionEndEvent(\n      aUUID,\n      bData,\n      getFixtureIndex(aData),\n      fixtureB.isSensor()\n    );\n  }\n\n  if (bUUID && activeCollisionListeners[bUUID]) {\n    sendCollisionEndEvent(\n      bUUID,\n      aData,\n      getFixtureIndex(bData),\n      fixtureA.isSensor()\n    );\n  }\n};\n","import {dynamicBodiesUuids, existingBodies, planckWorld} from \"./shared\";\nimport {Shape} from \"planck-js/lib/shape\";\nimport {activeCollisionListeners} from \"./collisions/data\";\nimport {addCachedBody, getCachedBody} from \"./cache\";\nimport type {BodyDef, FixtureOpt, Body, Joint} from \"planck-js\";\nimport {Box, Circle, DistanceJoint, RopeJoint, Vec2} from \"planck-js\";\nimport {ValidUUID} from \"../shared/types\";\nimport {syncBodies} from \"../shared\";\n\nexport enum BodyType {\n    static = 'static',\n    kinematic = 'kinematic',\n    dynamic = 'dynamic'\n}\n\nexport enum BodyShape {\n    box = 'box',\n    circle = 'circle',\n}\n\nexport type FixtureBase = {\n    shape: BodyShape,\n    fixtureOptions?: Partial<FixtureOpt>,\n}\n\nexport type BoxFixture = FixtureBase & {\n    hx: number,\n    hy: number,\n    center?: [number, number],\n    angle?: number,\n}\n\nexport const createBoxFixture = ({\n                                     width = 1,\n                                     height = 1,\n                                     center,\n                                        angle,\n                                     fixtureOptions = {}\n                                 }: {\n    width?: number,\n    height?: number,\n    angle?: number,\n    center?: [number, number],\n    fixtureOptions?: Partial<FixtureOpt>\n}): BoxFixture => {\n    const fixture: BoxFixture = {\n        shape: BodyShape.box,\n        hx: width,\n        hy: height,\n        fixtureOptions,\n    }\n    if (angle) {\n        fixture.angle = angle\n    }\n    if (center) {\n        fixture.center = center\n    }\n    return fixture\n}\n\nexport type CircleFixture = FixtureBase & {\n    radius: number,\n    position?: [number, number],\n}\n\nexport const createCircleFixture = ({ radius = 1, position, fixtureOptions = {} }: {\n    radius?: number,\n    position?: [number, number],\n    fixtureOptions?: Partial<FixtureOpt>\n}): CircleFixture => {\n    return {\n        shape: BodyShape.circle,\n        radius,\n        position,\n        fixtureOptions,\n    }\n}\n\ntype Fixture = BoxFixture | CircleFixture\n\ntype BasicBodyProps = Partial<BodyDef> & {\n    fixtures?: Fixture[],\n}\n\ntype AddBoxBodyProps = BasicBodyProps & {}\n\ntype AddCircleBodyProps = BasicBodyProps & {}\n\nexport type AddBodyDef = BasicBodyProps | AddBoxBodyProps | AddCircleBodyProps\n\nexport type AddBodyProps = AddBodyDef & {\n    uuid: ValidUUID,\n    listenForCollisions: boolean,\n    cacheKey?: string,\n    attachToRope?: boolean,\n}\n\nexport const addBody = ({uuid, cacheKey, listenForCollisions, fixtures = [], attachToRope = false, ...props}: AddBodyProps) => {\n\n    const existingBody = existingBodies.get(uuid)\n\n    if (existingBody) {\n        return existingBody\n    }\n\n    if (listenForCollisions) {\n        activeCollisionListeners[uuid] = true\n    }\n\n    const bodyDef: BodyDef = {\n        type: BodyType.static,\n        fixedRotation: true,\n        ...props,\n    }\n\n    const {type} = bodyDef\n\n    let body: Body | null = null;\n\n    if (cacheKey) {\n        const cachedBody = getCachedBody(cacheKey)\n        if (cachedBody) {\n\n            if (fixtures && fixtures.length > 0) {\n\n                let bodyFixture = cachedBody.getFixtureList()\n\n                fixtures.forEach((fixture, fixtureIndex) => {\n\n                    let fixtureOptions = fixture.fixtureOptions\n\n                    fixtureOptions = {\n                        userData: {\n                            uuid,\n                            fixtureIndex,\n                            ...fixtureOptions?.userData\n                        },\n                        ...fixtureOptions,\n                    }\n\n                    if (bodyFixture) {\n\n                        if (fixtureOptions) {\n                            bodyFixture.setUserData(fixtureOptions.userData)\n                        }\n\n                        bodyFixture = bodyFixture.getNext()\n                    }\n\n                })\n\n            }\n\n            const {position, angle} = props\n\n            if (position) {\n                cachedBody.setPosition(position)\n            }\n\n            if (angle) {\n                cachedBody.setAngle(angle)\n            }\n\n            cachedBody.setActive(true)\n\n            body = cachedBody\n\n        }\n    }\n\n    if (!body) {\n\n        body = planckWorld.createBody(bodyDef)\n\n        if (fixtures && fixtures.length > 0) {\n\n            fixtures.forEach((fixture, fixtureIndex) => {\n\n                const {shape} = fixture\n\n                let fixtureOptions = fixture.fixtureOptions ?? {}\n\n                fixtureOptions = {\n                    ...fixtureOptions,\n                    userData: {\n                        uuid,\n                        fixtureIndex,\n                        ...fixtureOptions?.userData\n                    },\n                }\n\n                let bodyShape: Shape;\n\n                switch (shape) {\n                    case BodyShape.box:\n                        const {hx, hy, center} = fixture as BoxFixture\n                        bodyShape = Box((hx as number) / 2, (hy as number) / 2, center ? Vec2(center[0], center[1]) : undefined) as unknown as Shape\n                        break;\n                    case BodyShape.circle:\n                        const {radius} = fixture as CircleFixture\n                        bodyShape = Circle((radius as number)) as unknown as Shape\n                        break;\n                    default:\n                        throw new Error(`Unhandled body shape ${shape}`)\n                }\n\n                if (fixtureOptions) {\n                    if (body) {\n                        body.createFixture(bodyShape, fixtureOptions as FixtureOpt)\n                    }\n                } else {\n                    if (body) {\n                        body.createFixture(bodyShape)\n                    }\n                }\n\n                // todo - handle rope properly...\n                if (attachToRope) {\n\n                    const {position, angle} = props\n\n                    const ropeJointDef = {\n                        maxLength: 0.5,\n                        localAnchorA: position,\n                        localAnchorB: position,\n                    };\n\n                    const startingBodyDef: BodyDef = {\n                        type: BodyType.static,\n                        fixedRotation: true,\n                        position,\n                        angle,\n                    }\n\n                    const startingBody = planckWorld.createBody(startingBodyDef)\n\n                    if (body) {\n\n                        const distanceJoint = DistanceJoint({\n                            collideConnected: false,\n                            frequencyHz: 5,\n                            dampingRatio: 0.5,\n                            length: 0.15,\n                        }, startingBody, body, position ?? Vec2(0, 0), position ?? Vec2(0, 0))\n\n                        const rope2 = planckWorld.createJoint(RopeJoint(ropeJointDef, startingBody, body, position ?? Vec2(0, 0)) as unknown as Joint);\n                        const rope = planckWorld.createJoint(distanceJoint as unknown as Joint);\n                    }\n\n\n                }\n\n            })\n\n\n        }\n\n    }\n\n    if (type !== BodyType.static) {\n        dynamicBodiesUuids.push(uuid)\n        syncBodies()\n    }\n\n    if (!body) {\n        throw new Error(`No body`)\n    }\n\n    existingBodies.set(uuid, body)\n\n    return body\n\n}\n\nexport type RemoveBodyProps = {\n    uuid: ValidUUID,\n    cacheKey?: string\n}\n\nconst tempVec = Vec2(0, 0)\n\nexport const removeBody = ({uuid, cacheKey}: RemoveBodyProps) => {\n    const index = dynamicBodiesUuids.indexOf(uuid)\n    if (index > -1) {\n        dynamicBodiesUuids.splice(index, 1)\n        syncBodies()\n    }\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    existingBodies.delete(uuid)\n    if (cacheKey) {\n        tempVec.set(-1000, -1000)\n        body.setPosition(tempVec)\n        tempVec.set(0, 0)\n        body.setLinearVelocity(tempVec)\n        body.setActive(false)\n        addCachedBody(cacheKey, body)\n    } else {\n        planckWorld.destroyBody(body)\n    }\n}\n\nexport type SetBodyProps = {\n    uuid: ValidUUID,\n    method: string,\n    methodParams: any[],\n}\n\nexport const setBody = ({uuid, method, methodParams}: SetBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    switch (method) {\n        //case 'setAngle':\n        //    const [angle] = methodParams\n        //    body.setTransform(body.getPosition(), angle)\n        //    break;\n        case 'setLinearVelocity':\n            // console.log('methodParams', methodParams[0].x, methodParams[0].y);\n            (body as any)[method](...methodParams)\n            break;\n        default:\n            (body as any)[method](...methodParams)\n    }\n}\n\nexport type UpdateBodyData = {\n    fixtureUpdate?: {\n        groupIndex?: number,\n        categoryBits?: number,\n        maskBits?: number,\n    }\n}\n\nexport type UpdateBodyProps = {\n    uuid: ValidUUID,\n    data: UpdateBodyData,\n}\n\nexport const updateBody = ({uuid, data}: UpdateBodyProps) => {\n    const body = existingBodies.get(uuid)\n    if (!body) {\n        console.warn(`Body not found for ${uuid}`)\n        return\n    }\n    const {fixtureUpdate} = data\n    if (fixtureUpdate) {\n        const fixture = body.getFixtureList()\n        if (fixture) {\n            const {\n                groupIndex,\n                categoryBits,\n                maskBits\n            } = fixtureUpdate\n            if (\n                groupIndex !== undefined || categoryBits !== undefined || maskBits !== undefined\n            ) {\n                const originalGroupIndex = fixture.getFilterGroupIndex()\n                const originalCategoryBits = fixture.getFilterCategoryBits()\n                const originalMaskBits = fixture.getFilterMaskBits()\n                fixture.setFilterData({\n                    groupIndex: groupIndex !== undefined ? groupIndex : originalGroupIndex,\n                    categoryBits: categoryBits !== undefined ? categoryBits : originalCategoryBits,\n                    maskBits: maskBits !== undefined ? maskBits : originalMaskBits,\n                })\n            }\n        }\n    }\n}\n","import React, {\n  createContext,\n  MutableRefObject,\n  useContext,\n  useRef,\n  useState,\n} from 'react';\nimport { ValidUUID } from '../shared/types';\nimport { Body } from 'planck-js';\n\ntype BodiesMap = Map<ValidUUID, Body>;\ntype DynamicBodies = Set<ValidUUID>;\ntype CollisionListeners = Set<ValidUUID>;\n\ntype ContextState = {\n  bodies: BodiesMap;\n  dynamicBodies: DynamicBodies;\n  collisionListeners: CollisionListeners;\n  bodiesNeedSync: boolean;\n  setBodiesNeedSync: (bool: boolean) => void;\n  bodiesNeedSyncRef: MutableRefObject<boolean>;\n  logicBodiesNeedSyncRef: MutableRefObject<boolean>;\n};\n\nconst Context = createContext((null as unknown) as ContextState);\n\nexport const useWorldState = (): ContextState => {\n  return useContext(Context);\n};\n\nexport const WorldState: React.FC = ({ children }) => {\n  const [bodies] = useState<BodiesMap>(() => new Map());\n  const [dynamicBodies] = useState<DynamicBodies>(() => new Set());\n  const [collisionListeners] = useState<CollisionListeners>(() => new Set());\n  const [bodiesNeedSync, setBodiesNeedSync] = useState(false);\n  const bodiesNeedSyncRef = useRef(false);\n  const logicBodiesNeedSyncRef = useRef(false);\n\n  return (\n    <Context.Provider\n      value={{\n        bodies,\n        dynamicBodies,\n        collisionListeners,\n        bodiesNeedSync,\n        setBodiesNeedSync,\n        bodiesNeedSyncRef,\n        logicBodiesNeedSyncRef,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { useAppContext, useWorld } from './appContext';\nimport { ValidUUID, WorkerMessageType } from '../shared/types';\nimport {\n  Body,\n  BodyDef,\n  Box,\n  Circle,\n  DistanceJoint,\n  FixtureOpt,\n  Joint,\n  RopeJoint,\n  Vec2,\n} from 'planck-js';\nimport {\n  AddBodyProps,\n  BodyShape,\n  BodyType,\n  BoxFixture,\n  CircleFixture,\n  RemoveBodyProps,\n  SetBodyProps,\n  UpdateBodyProps,\n} from '../planckjs/bodies';\nimport { Shape } from 'planck-js/lib/shape';\nimport { useWorldState } from './WorldState';\n\nconst tempVec = Vec2(0, 0);\n\nexport const useSubscribeToWorkerMessages = (\n  messageHandler: (event: MessageEvent) => void\n) => {\n  const { subscribe, logicSubscribe } = useAppContext();\n\n  useEffect(() => {\n    const unsubscribe = subscribe(messageHandler);\n\n    const unsubscribeLogic = logicSubscribe(messageHandler);\n\n    return () => {\n      unsubscribe();\n      unsubscribeLogic();\n    };\n  }, [subscribe, logicSubscribe, messageHandler]);\n};\n\ntype BodiesMap = Map<ValidUUID, Body>;\ntype CachedBodiesMap = Map<string, Body[]>;\n\nconst applyBodyConfigToExistingBody = (\n  body: Body,\n  data: AddBodyProps\n): Body => {\n  const {\n    uuid,\n    cacheKey,\n    listenForCollisions,\n    fixtures = [],\n    attachToRope = false,\n    ...props\n  } = data;\n\n  if (fixtures && fixtures.length > 0) {\n    let bodyFixture = body.getFixtureList();\n\n    fixtures.forEach((fixture, fixtureIndex) => {\n      let fixtureOptions = fixture.fixtureOptions;\n\n      fixtureOptions = {\n        userData: {\n          uuid,\n          fixtureIndex,\n          ...fixtureOptions?.userData,\n        },\n        ...fixtureOptions,\n      };\n\n      if (bodyFixture) {\n        if (fixtureOptions) {\n          bodyFixture.setUserData(fixtureOptions.userData);\n        }\n\n        bodyFixture = bodyFixture.getNext();\n      }\n    });\n  }\n\n  const { position, angle } = props;\n\n  if (position) {\n    body.setPosition(position);\n  }\n\n  if (angle) {\n    body.setAngle(angle);\n  }\n\n  body.setActive(true);\n\n  return body;\n};\n\nconst useAddBody = (bodies: BodiesMap, cachedBodies: CachedBodiesMap) => {\n  const {\n    dynamicBodies,\n    collisionListeners,\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n  } = useWorldState();\n\n  const addDynamicBody = useCallback(\n    (uuid: ValidUUID) => {\n      dynamicBodies.add(uuid);\n      bodiesNeedSyncRef.current = true;\n      logicBodiesNeedSyncRef.current = true;\n    },\n    [dynamicBodies, bodiesNeedSyncRef, logicBodiesNeedSyncRef]\n  );\n\n  const addCollisionListeners = useCallback(\n    (uuid: ValidUUID) => {\n      collisionListeners.add(uuid);\n    },\n    [collisionListeners]\n  );\n\n  const world = useWorld();\n\n  const getCachedBody = useCallback(\n    (cacheKey: string) => {\n      const cached = cachedBodies.get(cacheKey);\n\n      if (cached && cached.length > 0) {\n        const body = cached.pop();\n        if (body) {\n          return body;\n        }\n      }\n\n      return null;\n    },\n    [cachedBodies]\n  );\n\n  return useCallback(\n    (data: AddBodyProps) => {\n      const {\n        uuid,\n        cacheKey,\n        listenForCollisions,\n        fixtures = [],\n        attachToRope = false,\n        ...props\n      } = data;\n\n      const existingBody = bodies.get(uuid);\n\n      if (existingBody) {\n        return existingBody;\n      }\n\n      if (listenForCollisions) {\n        addCollisionListeners(uuid);\n      }\n\n      const bodyDef: BodyDef = {\n        type: BodyType.static,\n        fixedRotation: true,\n        ...props,\n      };\n\n      const { type } = bodyDef;\n\n      let body: Body | null = null;\n\n      if (cacheKey) {\n        let cachedBody = getCachedBody(cacheKey);\n\n        if (cachedBody) {\n          body = applyBodyConfigToExistingBody(cachedBody, data);\n        }\n      }\n\n      if (!body) {\n        body = world.createBody(bodyDef);\n\n        if (fixtures && fixtures.length > 0) {\n          fixtures.forEach((fixture, fixtureIndex) => {\n            const { shape } = fixture;\n\n            let fixtureOptions = fixture.fixtureOptions ?? {};\n\n            fixtureOptions = {\n              ...fixtureOptions,\n              userData: {\n                uuid,\n                fixtureIndex,\n                ...fixtureOptions?.userData,\n              },\n            };\n\n            let bodyShape: Shape;\n\n            switch (shape) {\n              case BodyShape.box:\n                const { hx, hy, center, angle } = fixture as BoxFixture;\n                bodyShape = (Box(\n                  (hx as number) / 2,\n                  (hy as number) / 2,\n                  center ? Vec2(center[0], center[1]) : undefined,\n                    angle,\n                ) as unknown) as Shape;\n                break;\n              case BodyShape.circle:\n                const { radius, position } = fixture as CircleFixture;\n                if (position) {\n                  bodyShape = (Circle(Vec2(position[0], position[1]), radius as number) as unknown) as Shape;\n                } else {\n                  bodyShape = (Circle(radius as number) as unknown) as Shape;\n                }\n                break;\n              default:\n                throw new Error(`Unhandled body shape ${shape}`);\n            }\n\n            if (fixtureOptions) {\n              if (body) {\n                body.createFixture(bodyShape, fixtureOptions as FixtureOpt);\n              }\n            } else {\n              if (body) {\n                body.createFixture(bodyShape);\n              }\n            }\n\n            // todo - handle rope properly...\n            if (attachToRope) {\n              const { position, angle } = props;\n\n              const ropeJointDef = {\n                maxLength: 0.5,\n                localAnchorA: position,\n                localAnchorB: position,\n              };\n\n              const startingBodyDef: BodyDef = {\n                type: BodyType.static,\n                fixedRotation: true,\n                position,\n                angle,\n              };\n\n              const startingBody = world.createBody(startingBodyDef);\n\n              if (body) {\n                const distanceJoint = DistanceJoint(\n                  {\n                    collideConnected: false,\n                    frequencyHz: 5,\n                    dampingRatio: 0.5,\n                    length: 0.15,\n                  },\n                  startingBody,\n                  body,\n                  position ?? Vec2(0, 0),\n                  position ?? Vec2(0, 0)\n                );\n\n                const rope2 = world.createJoint(\n                  (RopeJoint(\n                    ropeJointDef,\n                    startingBody,\n                    body,\n                    position ?? Vec2(0, 0)\n                  ) as unknown) as Joint\n                );\n                const rope = world.createJoint(\n                  (distanceJoint as unknown) as Joint\n                );\n              }\n            }\n          });\n        }\n      }\n\n      if (type !== BodyType.static) {\n        addDynamicBody(uuid);\n      }\n\n      if (!body) {\n        throw new Error(`No body`);\n      }\n\n      bodies.set(uuid, body);\n\n      return body;\n    },\n    [world, bodies, getCachedBody, addDynamicBody, addCollisionListeners]\n  );\n};\n\nconst useRemoveBody = (bodies: BodiesMap, cachedBodies: CachedBodiesMap) => {\n  const world = useWorld();\n  const {\n    dynamicBodies,\n    collisionListeners,\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n  } = useWorldState();\n\n  return useCallback(\n    ({ uuid, cacheKey }: RemoveBodyProps) => {\n      if (dynamicBodies.has(uuid)) {\n        dynamicBodies.delete(uuid);\n        bodiesNeedSyncRef.current = true;\n        logicBodiesNeedSyncRef.current = true;\n      }\n\n      collisionListeners.delete(uuid);\n\n      const body = bodies.get(uuid);\n\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`);\n        return;\n      }\n\n      bodies.delete(uuid);\n\n      if (cacheKey) {\n        tempVec.set(-1000, -1000);\n        body.setPosition(tempVec);\n        tempVec.set(0, 0);\n        body.setLinearVelocity(tempVec);\n        body.setActive(false);\n        const cached = cachedBodies.get(cacheKey);\n        if (cached) {\n          cached.push(body);\n        } else {\n          cachedBodies.set(cacheKey, [body]);\n        }\n      } else {\n        world.destroyBody(body);\n      }\n    },\n    [\n      world,\n      bodies,\n      dynamicBodies,\n      collisionListeners,\n      bodiesNeedSyncRef,\n      logicBodiesNeedSyncRef,\n      cachedBodies,\n    ]\n  );\n};\n\nconst useSetBody = (bodies: BodiesMap) => {\n  return useCallback(\n    ({ uuid, method, methodParams }: SetBodyProps) => {\n      const body = bodies.get(uuid);\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`, bodies);\n        return;\n      }\n      switch (method) {\n        default:\n          (body as any)[method](...methodParams);\n      }\n    },\n    [bodies]\n  );\n};\n\nconst useUpdateBody = (bodies: BodiesMap) => {\n  return useCallback(\n    ({ uuid, data }: UpdateBodyProps) => {\n      const body = bodies.get(uuid);\n      if (!body) {\n        console.warn(`Body not found for ${uuid}`);\n        return;\n      }\n      const { fixtureUpdate } = data;\n      if (fixtureUpdate) {\n        const fixture = body.getFixtureList();\n        if (fixture) {\n          const { groupIndex, categoryBits, maskBits } = fixtureUpdate;\n          if (\n            groupIndex !== undefined ||\n            categoryBits !== undefined ||\n            maskBits !== undefined\n          ) {\n            const originalGroupIndex = fixture.getFilterGroupIndex();\n            const originalCategoryBits = fixture.getFilterCategoryBits();\n            const originalMaskBits = fixture.getFilterMaskBits();\n            fixture.setFilterData({\n              groupIndex:\n                groupIndex !== undefined ? groupIndex : originalGroupIndex,\n              categoryBits:\n                categoryBits !== undefined\n                  ? categoryBits\n                  : originalCategoryBits,\n              maskBits: maskBits !== undefined ? maskBits : originalMaskBits,\n            });\n          }\n        }\n      }\n    },\n    [bodies]\n  );\n};\n\nexport const Bodies: React.FC = () => {\n  const { bodies } = useWorldState();\n  const [cachedBodies] = useState<CachedBodiesMap>(() => new Map());\n\n  const addBody = useAddBody(bodies, cachedBodies);\n  const removeBody = useRemoveBody(bodies, cachedBodies);\n  const setBody = useSetBody(bodies);\n  const updateBody = useUpdateBody(bodies);\n\n  const onMessage = useCallback(\n    (event: MessageEvent) => {\n      const { type, props = {} } = event.data as {\n        type: WorkerMessageType;\n        props: any;\n      };\n      switch (type) {\n        case WorkerMessageType.ADD_BODY:\n          addBody(props);\n          break;\n        case WorkerMessageType.REMOVE_BODY:\n          removeBody(props);\n          break;\n        case WorkerMessageType.SET_BODY:\n          setBody(props);\n          break;\n        case WorkerMessageType.UPDATE_BODY:\n          updateBody(props);\n          break;\n      }\n    },\n    [addBody, removeBody, setBody, updateBody]\n  );\n\n  useSubscribeToWorkerMessages(onMessage);\n\n  return null;\n};\n","import {useEffect, useRef, useState} from 'react';\nimport { Buffers } from '../shared/types';\nimport { useDidMount } from '../../../utils/hooks';\n\nexport const generateBuffers = (maxNumberOfDynamicObjects: number): Buffers => {\n  return {\n    positions: new Float32Array(maxNumberOfDynamicObjects * 2),\n    angles: new Float32Array(maxNumberOfDynamicObjects),\n  };\n};\n\nexport const useBuffers = (maxNumberOfDynamicObjects: number, debug: string): Buffers => {\n  const isMountRef = useRef(true)\n  const [buffers] = useState(() => generateBuffers(maxNumberOfDynamicObjects));\n\n  useEffect(() => {\n    if (isMountRef.current) {\n      isMountRef.current = false\n      return\n    }\n    const { positions, angles } = generateBuffers(maxNumberOfDynamicObjects);\n    buffers.positions = positions;\n    buffers.angles = angles;\n  }, [maxNumberOfDynamicObjects]);\n\n  return buffers;\n};\n","import React, {MutableRefObject, useCallback, useEffect, useRef, useState} from 'react';\nimport {useAppContext, useWorld} from './appContext';\nimport {Buffers, WorkerMessageType, WorkerOwnerMessageType,} from '../shared/types';\nimport {useWorldState} from './WorldState';\nimport {generateBuffers} from \"./buffers\";\n\nconst useSyncData = () => {\n  const { dynamicBodies, bodies } = useWorldState();\n  return useCallback((positions: Float32Array, angles: Float32Array) => {\n    const dynamicBodiesArray = Array.from(dynamicBodies);\n\n    dynamicBodiesArray.forEach((uuid, index) => {\n      const body = bodies.get(uuid);\n      if (!body) return;\n      const position = body.getPosition();\n      const angle = body.getAngle();\n      positions[2 * index + 0] = position.x;\n      positions[2 * index + 1] = position.y;\n      angles[index] = angle;\n    });\n  }, []);\n};\n\nconst debug = {\n  mainSent: false,\n  mainLogged: false,\n  mainLogged2: false,\n  logicSent: false,\n  logicLogged: false,\n  logicLogged2: false,\n};\n\nconst useSendPhysicsUpdate = (tickRef: MutableRefObject<number>) => {\n\n  const localStateRef = useRef({\n    failedMainCount: 0,\n    failedLogicCount: 0,\n    lastPhysicsStep: 0,\n  })\n\n  const {\n    bodiesNeedSyncRef,\n    logicBodiesNeedSyncRef,\n    dynamicBodies,\n  } = useWorldState();\n\n  const {\n    buffers: mainBuffers,\n    logicBuffers,\n    worker,\n    logicWorker,\n    maxNumberOfDynamicObjects,\n  } = useAppContext();\n\n  const syncData = useSyncData();\n\n  return useCallback(\n    (target: Worker | MessagePort, buffer: Buffers, isMain: boolean) => {\n      const { positions, angles } = buffer;\n      if (!(positions.byteLength !== 0 && angles.byteLength !== 0)) {\n        console.warn('cant send physics update to', isMain ? 'main' : 'logic')\n        if (isMain) {\n          if (localStateRef.current.failedMainCount >= 2) {\n            const { positions: newPositions, angles: newAngles } = generateBuffers(maxNumberOfDynamicObjects);\n            mainBuffers.positions = newPositions\n            mainBuffers.angles = newAngles\n          }\n        } else {\n          if (localStateRef.current.failedLogicCount >= 2) {\n            const {positions: newPositions, angles: newAngles} = generateBuffers(maxNumberOfDynamicObjects);\n            logicBuffers.positions = newPositions\n            logicBuffers.angles = newAngles\n          }\n        }\n        if (isMain) {\n          localStateRef.current.failedMainCount += 1\n        } else {\n          localStateRef.current.failedLogicCount += 1\n        }\n        return;\n      }\n      if (isMain) {\n        localStateRef.current.failedMainCount = 0\n      } else {\n        localStateRef.current.failedLogicCount = 0\n      }\n      syncData(positions, angles);\n      const rawMessage: any = {\n        type: WorkerOwnerMessageType.PHYSICS_STEP,\n        physicsTick: tickRef.current,\n      };\n      if (isMain) {\n        rawMessage.bodies = Array.from(dynamicBodies);\n        bodiesNeedSyncRef.current = false;\n      } else {\n        rawMessage.bodies = Array.from(dynamicBodies);\n        logicBodiesNeedSyncRef.current = false;\n      }\n      const message = {\n        ...rawMessage,\n        positions,\n        angles,\n      };\n      target.postMessage(message, [positions.buffer, angles.buffer]);\n    },\n    [bodiesNeedSyncRef, logicBodiesNeedSyncRef, tickRef, syncData]\n  );\n};\n\nconst useSendPhysicsUpdates = (tickRef: MutableRefObject<number>) => {\n  const {\n    buffers: mainBuffers,\n    logicBuffers,\n    worker,\n    logicWorker,\n  } = useAppContext();\n\n  const sendPhysicsUpdate = useSendPhysicsUpdate(tickRef);\n\n  const update = useCallback((isMain: boolean) => {\n    if (isMain) {\n      sendPhysicsUpdate(worker, mainBuffers, true);\n    } else if (logicWorker) {\n      sendPhysicsUpdate(logicWorker, logicBuffers, false);\n    }\n  }, [worker, logicWorker, sendPhysicsUpdate, mainBuffers, logicBuffers]);\n\n  const updateRef = useRef(update);\n\n  useEffect(() => {\n    updateRef.current = update;\n  }, [update, updateRef]);\n\n  return useCallback((isMain: boolean) => {\n    // using ref, as i don't want to interrupt the interval\n    updateRef.current(isMain);\n  }, [updateRef]);\n};\n\nconst useStepProcessed = (tickRef: MutableRefObject<number>) => {\n  const {\n    buffers: mainBuffers,\n    logicBuffers,\n    worker,\n    logicWorker,\n    buffersRef,\n  } = useAppContext();\n\n  return useCallback(\n    (\n      isMain: boolean,\n      lastProcessedPhysicsTick: number,\n      positions: Float32Array,\n      angles: Float32Array\n    ) => {\n      const buffers = isMain ? mainBuffers : logicBuffers;\n\n      if (isMain) {\n        buffers.positions = positions;\n        buffers.angles = angles;\n      } else {\n        buffers.positions = positions;\n        buffers.angles = angles;\n      }\n    },\n    [mainBuffers, logicBuffers, tickRef, worker, logicWorker]\n  );\n};\n\nconst useWorldLoop = () => {\n  const world = useWorld();\n  const { updateRate, subscribe, logicSubscribe } = useAppContext();\n  const tickRef = useRef(0);\n  const [tickCount, setTickCount] = useState(0)\n\n  const lastSentMainUpdateRef = useRef(-1)\n  const lastSentLogicUpdateRef = useRef(-1)\n  const [mainBufferReady, setMainBufferReady] = useState(false)\n  const [logicBufferReady, setLogicBufferReady] = useState(false)\n  const sendPhysicsUpdate = useSendPhysicsUpdates(tickRef);\n\n  useEffect(() => {\n\n    if (mainBufferReady && lastSentMainUpdateRef.current < tickCount) {\n      sendPhysicsUpdate(true)\n      lastSentMainUpdateRef.current = tickCount\n      setMainBufferReady(false)\n    }\n\n  }, [tickCount, mainBufferReady])\n\n  useEffect(() => {\n\n    if (logicBufferReady && lastSentLogicUpdateRef.current < tickCount) {\n      sendPhysicsUpdate(false)\n      lastSentLogicUpdateRef.current = tickCount\n      setLogicBufferReady(false)\n    }\n\n  }, [tickCount, logicBufferReady])\n\n  useEffect(() => {\n\n    const step = () => {\n      world.step(updateRate);\n    };\n\n    const interval = setInterval(() => {\n      tickRef.current += 1;\n      setTickCount(state => state + 1)\n      step();\n    }, updateRate);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n\n  const stepProcessed = useStepProcessed(tickRef);\n\n  useEffect(() => {\n\n    const onMessage = (event: MessageEvent, isMain: boolean = true) => {\n      const { type, props = {} } = event.data as {\n        type: WorkerMessageType;\n        props: any;\n      };\n      if (type === WorkerMessageType.READY_FOR_PHYSICS) {\n        if (isMain) {\n          setMainBufferReady(true)\n        } else {\n          setLogicBufferReady(true)\n        }\n      } else if (type === WorkerMessageType.PHYSICS_STEP_PROCESSED) {\n        stepProcessed(\n          isMain,\n          event.data.physicsTick,\n          event.data.positions,\n          event.data.angles\n        );\n        if (isMain) {\n          setMainBufferReady(true)\n        } else {\n          setLogicBufferReady(true)\n        }\n      }\n    };\n\n    const unsubscribe = subscribe(onMessage);\n\n    const unsubscribeLogic = logicSubscribe(event => onMessage(event, false));\n\n    return () => {\n      unsubscribe();\n      unsubscribeLogic();\n    };\n  }, [subscribe, logicSubscribe, stepProcessed]);\n};\n\nexport const World: React.FC = () => {\n  useWorldLoop();\n  return null;\n};\n","import React, { useCallback, useEffect } from 'react';\nimport { useAppContext, useWorld } from './appContext';\nimport { Contact, Fixture } from 'planck-js';\nimport {\n  getFixtureData,\n  getFixtureIndex,\n  getFixtureUuid,\n} from '../planckjs/collisions/collisions';\nimport { useWorldState } from './WorldState';\nimport { WorkerOwnerMessageType } from '../shared/types';\n\nconst useHandleBeginCollision = () => {\n  const { worker, logicWorker } = useAppContext();\n  const { collisionListeners } = useWorldState();\n  const sendCollisionBeginEvent = useCallback(\n    (uuid: string, data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => {\n      const update = {\n        type: WorkerOwnerMessageType.BEGIN_COLLISION,\n        props: {\n          uuid,\n          data,\n          fixtureIndex,\n        collidedFixtureIndex,\n          isSensor,\n        },\n      };\n      worker.postMessage(update);\n      if (logicWorker) {\n        logicWorker.postMessage(update);\n      }\n    },\n    [worker, logicWorker]\n  );\n\n  return useCallback(\n    (fixtureA: Fixture, fixtureB: Fixture) => {\n      const aData = getFixtureData(fixtureA);\n      const bData = getFixtureData(fixtureB);\n      const aUUID = getFixtureUuid(aData);\n      const bUUID = getFixtureUuid(bData);\n\n      if (aUUID && collisionListeners.has(aUUID)) {\n        sendCollisionBeginEvent(\n          aUUID,\n          bData,\n          getFixtureIndex(aData),\n          getFixtureIndex(bData),\n          fixtureB.isSensor()\n        );\n      }\n\n      if (bUUID && collisionListeners.has(bUUID)) {\n        sendCollisionBeginEvent(\n          bUUID,\n          aData,\n          getFixtureIndex(bData),\n          getFixtureIndex(aData),\n          fixtureA.isSensor()\n        );\n      }\n    },\n    [collisionListeners, sendCollisionBeginEvent]\n  );\n};\n\nconst useHandleEndCollision = () => {\n  const { worker, logicWorker } = useAppContext();\n  const { collisionListeners } = useWorldState();\n\n  const sendCollisionEndEvent = useCallback(\n    (uuid: string, data: any, fixtureIndex: number, collidedFixtureIndex: number, isSensor: boolean) => {\n      const update = {\n        type: WorkerOwnerMessageType.END_COLLISION,\n        props: {\n          uuid,\n          data,\n          fixtureIndex,\n            collidedFixtureIndex,\n          isSensor,\n        },\n      };\n      worker.postMessage(update);\n      if (logicWorker) {\n        logicWorker.postMessage(update);\n      }\n    },\n    [worker, logicWorker]\n  );\n\n  return useCallback(\n    (fixtureA: Fixture, fixtureB: Fixture) => {\n      const aData = getFixtureData(fixtureA);\n      const bData = getFixtureData(fixtureB);\n      const aUUID = getFixtureUuid(aData);\n      const bUUID = getFixtureUuid(bData);\n\n      if (aUUID && collisionListeners.has(aUUID)) {\n        sendCollisionEndEvent(\n          aUUID,\n          bData,\n          getFixtureIndex(aData),\n          getFixtureIndex(bData),\n          fixtureB.isSensor()\n        );\n      }\n\n      if (bUUID && collisionListeners.has(bUUID)) {\n        sendCollisionEndEvent(\n          bUUID,\n          aData,\n          getFixtureIndex(bData),\n          getFixtureIndex(aData),\n          fixtureA.isSensor()\n        );\n      }\n    },\n    [collisionListeners, sendCollisionEndEvent]\n  );\n};\n\nexport const Collisions: React.FC = () => {\n  const world = useWorld();\n\n  const handleBeginCollision = useHandleBeginCollision();\n  const handleEndCollision = useHandleEndCollision();\n\n  useEffect(() => {\n    world.on('begin-contact', (contact: Contact) => {\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      handleBeginCollision(fixtureA, fixtureB);\n    });\n\n    world.on('end-contact', (contact: Contact) => {\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      handleEndCollision(fixtureA, fixtureB);\n    });\n  }, [world]);\n\n  return null;\n};\n","import React, { useEffect, useRef, useState } from 'react';\nimport { Vec2, World, WorldDef } from 'planck-js';\nimport { AppContext } from './appContext';\nimport { useWorkerMessages } from '../../hooks/useWorkerMessages';\nimport { Bodies } from './Bodies';\nimport { World as WorldComponent } from './World';\nimport { useSubscribeLogicWorker, useLogicWorker } from './logicWorker';\nimport { WorldState } from './WorldState';\nimport { Collisions } from './Collisions';\nimport { WorkerOwnerMessageType } from '../shared/types';\nimport { useBuffers } from './buffers';\n\nexport const App: React.FC<{\n  config: {\n    maxNumberOfDynamicObjects: number;\n    updateRate: number;\n  };\n  worldParams: WorldDef;\n  worker: Worker;\n}> = ({ worldParams, worker, config }) => {\n  const { updateRate, maxNumberOfDynamicObjects } = config;\n\n  const defaultParams = {\n    allowSleep: true,\n    gravity: Vec2(0, 0),\n    ...worldParams,\n  };\n\n  const [world] = useState(() => World(defaultParams));\n\n  const subscribe = useWorkerMessages(worker);\n\n  const logicWorker = useLogicWorker(worker, subscribe);\n\n  const logicSubscribe = useSubscribeLogicWorker(logicWorker);\n\n  const buffers = useBuffers(maxNumberOfDynamicObjects, 'main');\n  const logicBuffers = useBuffers(!logicWorker ? 0 : maxNumberOfDynamicObjects, 'logic');\n\n  const buffersRef = useRef({\n    mainCount: 0,\n    logicCount: 0,\n  });\n\n  useEffect(() => {\n    worker.postMessage({\n      type: WorkerOwnerMessageType.INITIATED,\n    });\n  }, [worker]);\n\n  return (\n    <AppContext.Provider\n      value={{\n        world,\n        updateRate,\n        worker,\n        logicWorker,\n        subscribe,\n        logicSubscribe,\n        buffers,\n        logicBuffers,\n        buffersRef,\n        maxNumberOfDynamicObjects,\n      }}\n    >\n      <WorldState>\n        <WorldComponent />\n        <Bodies />\n        <Collisions />\n      </WorldState>\n    </AppContext.Provider>\n  );\n};\n","import { Subscribe, useWorkerMessages } from '../../hooks/useWorkerMessages';\nimport { useEffect, useState } from 'react';\n\nexport const useSubscribeLogicWorker = (\n  worker: Worker | MessagePort | undefined\n) => {\n  const subscribe = useWorkerMessages(worker);\n  return subscribe;\n};\n\nexport const useLogicWorker = (\n  worker: Worker,\n  subscribe: Subscribe\n): undefined | Worker | MessagePort => {\n  const [logicWorker, setLogicWorker] = useState<MessagePort>();\n\n  useEffect(() => {\n    let logicWorkerPort: MessagePort;\n\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data.command === 'connect') {\n        logicWorkerPort = event.ports[0];\n        setLogicWorker(logicWorkerPort);\n        return;\n      } else if (event.data.command === 'forward') {\n        logicWorkerPort.postMessage(event.data.message);\n        return;\n      }\n    };\n\n    const unsubscribe = subscribe(event => {\n      if (event.data.command) {\n        handleMessage(event);\n      }\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [worker, subscribe, setLogicWorker]);\n\n  return logicWorker;\n};\n"],"names":["WorkerMessageType","WorkerOwnerMessageType","AppContext","createContext","useWorld","useContext","world","useAppContext","useWorkerMessages","worker","idCount","useRef","subscriptionsRef","subscribe","useCallback","callback","id","current","useEffect","previousOnMessage","onmessage","event","Object","values","forEach","BodyType","BodyShape","getFixtureData","fixture","getUserData","getFixtureUuid","data","uuid","getFixtureIndex","fixtureIndex","Context","useWorldState","WorldState","children","bodies","useState","Map","dynamicBodies","Set","collisionListeners","bodiesNeedSync","setBodiesNeedSync","bodiesNeedSyncRef","logicBodiesNeedSyncRef","React","Provider","value","tempVec","Vec2","Bodies","messageHandler","logicSubscribe","cachedBodies","addBody","addDynamicBody","add","addCollisionListeners","getCachedBody","cacheKey","cached","get","length","body","pop","listenForCollisions","fixtures","attachToRope","props","existingBody","bodyDef","type","fixedRotation","cachedBody","bodyFixture","getFixtureList","fixtureOptions","userData","_fixtureOptions","setUserData","getNext","position","angle","setPosition","setAngle","setActive","applyBodyConfigToExistingBody","createBody","bodyShape","shape","_fixtureOptions2","box","center","Box","hx","hy","undefined","circle","radius","Circle","Error","createFixture","ropeJointDef","maxLength","localAnchorA","localAnchorB","startingBody","distanceJoint","DistanceJoint","collideConnected","frequencyHz","dampingRatio","createJoint","RopeJoint","set","useAddBody","removeBody","has","setLinearVelocity","push","destroyBody","console","warn","useRemoveBody","setBody","method","methodParams","useSetBody","updateBody","fixtureUpdate","groupIndex","categoryBits","maskBits","originalGroupIndex","getFilterGroupIndex","originalCategoryBits","getFilterCategoryBits","originalMaskBits","getFilterMaskBits","setFilterData","useUpdateBody","onMessage","ADD_BODY","REMOVE_BODY","SET_BODY","UPDATE_BODY","unsubscribe","unsubscribeLogic","generateBuffers","maxNumberOfDynamicObjects","positions","Float32Array","angles","useBuffers","debug","isMountRef","buffers","World","updateRate","tickRef","tickCount","setTickCount","lastSentMainUpdateRef","lastSentLogicUpdateRef","mainBufferReady","setMainBufferReady","logicBufferReady","setLogicBufferReady","sendPhysicsUpdate","mainBuffers","logicBuffers","logicWorker","localStateRef","failedMainCount","failedLogicCount","lastPhysicsStep","syncData","Array","from","index","getPosition","getAngle","x","y","useSyncData","target","buffer","isMain","byteLength","rawMessage","PHYSICS_STEP","physicsTick","message","postMessage","newAngles","useSendPhysicsUpdate","update","updateRef","useSendPhysicsUpdates","interval","setInterval","state","step","clearInterval","stepProcessed","lastProcessedPhysicsTick","useStepProcessed","READY_FOR_PHYSICS","PHYSICS_STEP_PROCESSED","useWorldLoop","Collisions","sendCollisionBeginEvent","handleBeginCollision","collidedFixtureIndex","isSensor","BEGIN_COLLISION","fixtureA","fixtureB","aData","bData","aUUID","bUUID","handleEndCollision","sendCollisionEndEvent","END_COLLISION","useHandleEndCollision","on","contact","getFixtureA","getFixtureB","worldParams","config","defaultParams","allowSleep","gravity","setLogicWorker","logicWorkerPort","command","ports","handleMessage","useLogicWorker","useSubscribeLogicWorker","buffersRef","mainCount","logicCount","INITIATED","WorldComponent"],"mappings":"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"}